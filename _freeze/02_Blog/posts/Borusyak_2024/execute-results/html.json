{
  "hash": "dfa276859a61093e2bda1cde86a705f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Borusyak et al. (2024)\"\ndate: 2024-08-19\ncategories: [Causal Inference]\n---\n\n\n## 文献\n\nBorusyak, Kirill, Xavier Jaravel & Jann Spiess, 2024, \"Revisiting Event-Study Designs: Robust and Efficient Estimation,\" _The Review of Economic Studies_, ([10.1093/restud/rdae007](https://doi.org/10.1093/restud/rdae007)).\n\n## ざっくりとした要約\n\nDiD推定をg-computationのようなアイデアで行う手法を提案した論文です。従来のTwo-way fixed effectによる推定では問題が生じることが指摘されてきた、処置のタイミングによる効果の異質性（staggerd DiD design）の問題などに対処しています。通常g-computationによる推定量の標準誤差はBootstrapで計算することが多いと思うのですが、この論文では推定量の漸近正規性などを示しつつ、Bootstrapを使わずに標準誤差を計算する方法を提案している点が興味深いです。\n\n## Estimand\n\n- $Y_{it}(1), Y_{it}(0)$：個人$i$、時点$t$における介入を受けた場合と受けていない場合のpotential outcome\n- $D_{it}$：介入を受けたかどうかのバイナリ変数\n\n個人レベルの因果効果\n\n\\begin{align*}\n\\tau_{it} = Y_{it}(1) - Y_{it}(0) = Y_{it} - Y_{it}(0)\n\\end{align*}\n\nこれを関心のある集団について平均する\n\n- ATT：$\\mathrm{E}[\\tau_{it}|D_{it} = 1] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1]$\n- event study：$\\mathrm{E}[\\tau_{it}|D_{it} = 1, T = t] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1, T = t]$\n- 特定の集団におけるATT：$\\mathrm{E}[\\tau_{it}|D_{it} = 1, Gender] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1, Gender]$\n\n論文ではウェイトを使った書き方をしているのでややこしいが、おそらくはこういうことだと思われる。\n\n## 識別\n\n因果効果を識別するための仮定は以下の通り\n\n1. General moodel of $Y(0)$：$\\mathrm{E}[Y_{it}(0)] = A'_{it}\\lambda_i + X'_{it}\\delta$の形で書けること\n  - $A'_{it}\\lambda_i$：個体の固定効果＋固定効果と共変量の交互作用\n  - $X'_{it}\\delta$：時点の固定効果＋時変の共変量\n  - 要するに$\\mathrm{E}[Y_{it}(0)]$が適切のモデル化できていること\n2. No-anticipation effects：$Y_{it} = Y_{it}(0) \\ if \\ D_{it} = 0$\n  - Consistencyと同じ？\n3. Model of causal effects\n  - 効果の異質性がパラメトリックモデルで書けること（？）\n  - 複雑すぎるとダメということ？このあたりちょっとわからなかったです\n\n## 推定\n\n1. $\\mathrm{E}[Y_{it}(0)]$の推定\n\n- 処置を受けていないサンプル（$D_{it} = 0$）を用いて、以下のモデルをOLSで推定\n\n$$\nY_{it} = A'_{it}\\lambda_i + X'_{it}\\delta + \\varepsilon_{it}\n$$\n\n2. $\\hat{Y}_{it}(0) | D_{it} = 1$ の推定\n\n- 推定したモデルに、処置を受けたサンプル（$D_{it} = 1$）を代入し、処置を受けたサンプルにおいて、処置を受けていなかった場合のpotential outcomeを予測\n\n3. $\\hat{\\tau}_{it}$の推定\n\n- 処置を受けたサンプルの、観察データ$Y_{it}$と予測したpotential outcome$\\hat{Y}_{it}(0)$の差を取る\n\n4. 関心のある集団について平均値をとる\n\n$$\n\\mathrm{ATT} = \\mathrm{E}[\\hat{\\tau}_{it}|D_{it} = 1]\n$$\n\n標準誤差の推定も説明があるが、理解できなかった...\n\n## 分析例\n\n著者によるStataパッケージの他、RではKyle Buttsによる[`didimputation`](https://github.com/kylebutts/didimputation)パッケージがある。\n\nここでは`didimputation`パッケージのトイデータを用いて、パッケージによる結果と、手計算による結果を比較する。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github('kylebutts/didimputation')\nlibrary(tidyverse)\nlibrary(fixest)\nlibrary(didimputation)\n```\n:::\n\n\n## パッケージの結果\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndid_imputation(data = df_het, yname = \"dep_var\", gname = \"g\", tname = \"year\", idname = \"unit\") |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|term  | estimate| std.error| conf.low| conf.high|\n|:-----|--------:|---------:|--------:|---------:|\n|treat | 2.262952| 0.0313968| 2.201414|   2.32449|\n\n\n:::\n:::\n\n\n## 手計算\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# OLSで処置を受けていないサンプルにおけるモデルを推定\nmodel <- feols(dep_var ~ 1 | year + unit, data = df_het |> filter(!treat), combine.quick = TRUE)\n\nprediction <- \n  # 処置を受けた集団の予測値（potential outcome）を計算\n  broom::augment(model, newdata = df_het |> filter(treat)) |> \n  # 差分を計算\n  mutate(tau = dep_var - .fitted) \n\n# 集計\nprediction |> \n  summarise(\n    ATT = mean(tau)\n  ) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|      ATT|\n|--------:|\n| 2.262952|\n\n\n:::\n:::\n\n\nATTの点推定値は一致する。\n\n## 集団による異質性\n\n次に、処置のタイミングにより効果が異なる場合の分析を考える。\n\nパッケージでは以下のように、処置のタイミングが同じグループごとにウェイトを作成してやることで、集団ごとの効果を推定できる。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_het |> \n  mutate(\n    group1 = case_when(\n      group == 'Group 1' & treat ~ 1,\n      .default = 0\n    ),\n    group2 = case_when(\n      group == 'Group 2' & treat ~ 1,\n      .default = 0\n    )\n  ) |> \n  did_imputation(yname = \"dep_var\", gname = \"g\", tname = \"year\", idname = \"unit\", wtr = c('group1', 'group2')) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|term   | estimate| std.error| conf.low| conf.high|\n|:------|--------:|---------:|--------:|---------:|\n|group1 | 2.513439| 0.0381686| 2.438629|  2.588249|\n|group2 | 1.795048| 0.0389609| 1.718685|  1.871412|\n\n\n:::\n:::\n\n\n手計算では、集計をグループごとに行えばよい。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 集計\nprediction |> \n  summarise(\n    ATT = mean(tau),\n    .by = c(group)\n  ) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|group   |      ATT|\n|:-------|--------:|\n|Group 1 | 2.513439|\n|Group 2 | 1.795048|\n\n\n:::\n:::\n\n\n\nこちらも点推定値は一致する。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}