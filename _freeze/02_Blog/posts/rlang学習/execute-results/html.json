{
  "hash": "f9f35e05adc255d5cb1048c6b0880307",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"rlang学習\"\ndate: 2024-02-22\ncategories: [Others]\n---\n\n\n## 参考\n\n[Advanced R](https://adv-r.hadley.nz/)\n\n## 下準備\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(lobstr)\n```\n:::\n\n\n## expression\n\n- `expr`：コードをそのまま捕まえる\n  - 作成されたオブジェクト：**expression**\n  - call, symbol, constant, pairlistの4つからなる\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr(mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmean(x, na.rm = TRUE)\n```\n\n\n:::\n\n```{.r .cell-code}\nexpr(10 + 100 + 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10 + 100 + 1000\n```\n\n\n:::\n:::\n\n\n- `expr`は関数の引数なども書いてあるまま保持する\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# これはxになる\ncapture_it <- function(x) {\n  expr(x)\n}\n\ncapture_it(a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\n```\n\n\n:::\n:::\n\n\n- 引数は評価した上でコードを保持したい場合は`enexpr`を使う\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncapture_it <- function(x) {\n  enexpr(x)\n}\ncapture_it(a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na + b + c\n```\n\n\n:::\n:::\n\n\n## abstract syntax tree (AST) による表現\n\n- codeはtree形式で表現できる\n- fがcall, aがsymbol, \"b\"がconstantらしい\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(f(a, \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█─f \n├─a \n└─\"b\" \n```\n\n\n:::\n:::\n\n\n\n- `+`や`*`も関数であることがわかる\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(1 + 2 * 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█─`+` \n├─1 \n└─█─`*` \n  ├─2 \n  └─3 \n```\n\n\n:::\n:::\n\n\n\n## codeを生成するcode\n\n- `call2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncall2('f', 1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf(1, 2)\n```\n\n\n:::\n\n```{.r .cell-code}\ncall2('+', 1, call2('*', 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 + 2 * 3\n```\n\n\n:::\n:::\n\n\n- `!!`を使ったcodeの生成\n  - 捕まえておいたコードを評価したいところで評価する\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- expr(x + x)\nyy <- expr(y + y)\n\nexpr(!!xx / !!yy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(x + x)/(y + y)\n```\n\n\n:::\n:::\n\n\n## codeの評価\n\n- `eval(expr, env)`：exprをenvで評価\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval(expr(x + y), env(x = 1, y = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\neval(expr(x + y), env(x = 2, y = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 102\n```\n\n\n:::\n:::\n\n\n- envを指定しないときは現在のenvironmentで評価\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 100\n\neval(expr(x + y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n\n- データを環境として扱う\n\n- `eval_tidy(expr, data)`：exprをdata内部で評価\n  - dataでcurrent environmentを上書きするので**data-mask**呼ばれる\n- `eval`でもできないことはないが、落とし穴があるらしい\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5 5 9 9\n```\n\n\n:::\n:::\n\n\n- dplyrっぽい関数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5 5 9 9\n```\n\n\n:::\n:::\n\n\n\n## Quosure\n\n- exprだけを使う方法は問題がでてくる\n- 関数の内部で`a`を定義してみる\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enexpr(expr), df)\n}\n```\n:::\n\n\n- さらに関数の外部（global environment）でも`a`を定義する\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3)\na <- 10\n```\n:::\n\n\n- この状態で`with2`を使うと問題が発生\n  - global environmentの`a`ではなく、関数内部で定義した`a`が優先的に使われる\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2(df, x + a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1001 1002 1003\n```\n\n\n:::\n:::\n\n\n- quosure：expressionとenvironmentをセットで保持する\n  - data-maskでは、eval_tidyのdata -> quosureのenv -> global envの順で評価される\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enquo(expr), df)\n}\n\nx <- 10\n\nwith2(df, x + a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13\n```\n\n\n:::\n:::\n\n\n# Quasiquotation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(purrr)\n```\n:::\n\n\n- pasteっぽい関数を作る\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste('Good', 'morning', 'Hadley')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good morning Hadley\"\n```\n\n\n:::\n:::\n\n\n- 毎回''でくくるのがだるい\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncement <- function(...) {\n  args <- ensyms(...) |> map_chr(as_string)\n  paste(args, collapse = \" \")\n}\n\ncement(Good, morning, Hadley)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good morning Hadley\"\n```\n\n\n:::\n:::\n\n\n- morningやeveryoneが変数だったら？\n  - pasteだとうまくいくけど、cementは想定したふうにはならない\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime <- 'afternoon'\nname <- 'Alice'\n\npaste('Good', time, name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good afternoon Alice\"\n```\n\n\n:::\n\n```{.r .cell-code}\ncement(Good, time, name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good time name\"\n```\n\n\n:::\n:::\n\n\n-- `!!`を使って変数を評価すればうまくいく\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncement(Good, !!time, !!name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good afternoon Alice\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}