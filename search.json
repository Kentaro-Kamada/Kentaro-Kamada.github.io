[
  {
    "objectID": "profile.en.html",
    "href": "profile.en.html",
    "title": "Profile",
    "section": "",
    "text": "April 2023 - Present: Research Fellow (DC1), Japan Society for the Promotion of Science (JSPS)\nApril 2021 - Present: Project Academic Specialist, Center for Social Research and Data Archives, Institute of Social Science, The University of Tokyo"
  },
  {
    "objectID": "profile.en.html#position",
    "href": "profile.en.html#position",
    "title": "Profile",
    "section": "",
    "text": "April 2023 - Present: Research Fellow (DC1), Japan Society for the Promotion of Science (JSPS)\nApril 2021 - Present: Project Academic Specialist, Center for Social Research and Data Archives, Institute of Social Science, The University of Tokyo"
  },
  {
    "objectID": "profile.en.html#education",
    "href": "profile.en.html#education",
    "title": "Profile",
    "section": "Education",
    "text": "Education\n\nApril 2023 - Present: Ph.D. Student in Division of Social Sciences in Education, Graduate School of Education, The University of Tokyo\nApril 2021 - March 2023: M.A. in Division of Social Sciences in Education, Graduate School of Education, The University of Tokyo\nApril 2019 - March 2021: B.A. in Division of Social Sciences in Education, Faculty of Education, The University of Tokyo"
  },
  {
    "objectID": "blog/posts/TMLE.html",
    "href": "blog/posts/TMLE.html",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "参考ページ：https://www.khstats.com/blog/tmle/tutorial-pt2\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(sl3)\nlibrary(tmle3)\nlibrary(future)\n\nkable &lt;- partial(\n  knitr::kable,\n  digits = 3\n)\n\nplan(multisession, workers = 8)\n\nset.seed(7)\n\n\n\n\n\n元のサイトでは\\(Y\\)が2値変数になっていて、推定が真値と一致しているかどうかの評価が難しいので、ここでは\\(Y\\)を連続変数としている。\nATEの真値は0.3に設定\n\n\ngenerate_data &lt;- function(n){ \n    W1 &lt;- rbinom(n, size=1, prob=0.2) # binary confounder\n    W2 &lt;- rbinom(n, size=1, prob=0.5) # binary confounder\n    W3 &lt;- round(runif(n, min=2, max=7)) # continuous confounder\n    W4 &lt;- round(runif(n, min=0, max=4)) # continuous confounder\n    A  &lt;- rbinom(n, size=1, prob= plogis(-0.2 + 0.2*W2 + log(0.1*W3) + 0.3*W4 + 0.2*W1*W4)) # binary treatment depends on confounders\n    Y &lt;- -1 + 0.3*A - 0.1*W1 + 0.2*W2 + 0.3*W3 - 0.1*W4 + sin(0.1*W2*W4) # continuous outcome depends on confounders\n    return(tibble(Y, W1, W2, W3, W4, A))\n}\n\nn &lt;- 1000\ndat_obs &lt;- generate_data(n) # generate a data set with n observations\n\n\ndat_obs |&gt; \n  summarise(samplemean = mean(Y), .by = A)\n\n# A tibble: 2 × 2\n      A samplemean\n  &lt;int&gt;      &lt;dbl&gt;\n1     1      0.686\n2     0      0.237\n\n\n\n\n\n\nglm、Lasso、Random forest、Multivariate adaptive regression splineをスタッキング\n\n\nsl_libs &lt;-\n  Lrnr_sl$new(\n    learners = Stack$new(\n      Lrnr_glm$new(), \n      Lrnr_glmnet$new(alpha = 1), \n      Lrnr_ranger$new(num.trees = 2000, max.depth = 3), \n      Lrnr_earth$new()\n    )\n  )\n\n\n\n\n\n\n\n\\[\n{\\mathrm E}[Y | A, W]\n\\]\n\ntask &lt;- \n  sl3_Task$new(\n    dat_obs, \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\ntask_A1 &lt;- \n  sl3_Task$new(\n    dat_obs |&gt; mutate(A = 1), \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\ntask_A0 &lt;- \n  sl3_Task$new(\n    dat_obs |&gt; mutate(A = 0), \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\n# 全サンプルで学習\nsl_fit &lt;- sl_libs$train(task)\n\n\n以下の3つの予測値を算出\n\\(A := 1\\)は全サンプルでAを1にする（\\(A = 1\\)はサンプルのうちのAが1となる部分集団）\n\n\\[\\begin{align}\n&{\\mathrm E}[Y | A, W] \\\\\n&{\\mathrm E}[Y | A := 1, W] \\\\\n&{\\mathrm E}[Y | A := 0, W]\n\\end{align}\\]\n\ndat_tmle1 &lt;- \n  dat_obs |&gt; \n  mutate(\n    # 観測サンプルについての予測値\n    Q_A = sl_fit$predict(task),\n    # 全てのサンプルでA = 1に固定したときの予測値\n    Q_A1 = sl_fit$predict(task_A1),\n    # 全てのサンプルでA = 0に固定した時の予測値\n    Q_A0 = sl_fit$predict(task_A0)\n  )\n\n\nstandardization（g-computation）によるATE\n\n\\[\nATE_{g \\mathrm{-}comp} = {\\mathrm E}[ {\\mathrm E}[Y | A := 1, W] - {\\mathrm E}[Y | A := 0, W]]\n\\]\n\ndat_tmle1 |&gt; \n  summarise(ATE = mean(Q_A1 - Q_A0))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300\n\n\n\n\n\n\n\n傾向スコアを機械学習モデルにより予測\n\n\\[\n\\mathrm{Pr}(A = 1 | W)\n\\]\n\ntask_g &lt;- \n  sl3_Task$new(\n    data = dat_obs, \n    covariates = select(dat_obs, !c(Y, A)) |&gt; names(), \n    outcome = 'A', \n    outcome_type = 'binomial', \n    folds = 8\n  )\n\nsl_fit_g &lt;- sl_libs$train(task_g)\n\n\n\n\n傾向スコアからClever Covariateと呼ばれる情報を作成（IPWに似ている）\n\n\\[\\begin{align}\n&H(A,W) &= \\frac{A}{\\mathrm{Pr}(A = 1 | W)} - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)} \\\\\n&H(1,W) &= \\frac{A}{\\mathrm{Pr}(A = 1 | W)} \\\\\n&H(0,W) &= - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)}\n\\end{align}\\]\n\ndat_tmle2 &lt;- \n  dat_tmle1 |&gt; \n  mutate(\n    # Propensity Scoreの予測\n    ps = sl_fit_g$predict(task_g),\n    # ipw (Inverse Probability Weight)\n    ipw = case_when(\n      A == 1 ~ 1 / ps, \n      A == 0 ~ 1 / (1 - ps)\n    ),\n    # Clever Covariates\n    H_A = case_when(\n      A == 1 ~ 1 / ps,\n      A == 0 ~ -1 / (1 - ps)\n    ),\n    H_A1 = case_when(\n      A == 1 ~ H_A,\n      A == 0 ~ 0\n    ),\n    H_A0 = case_when(\n      A == 1 ~ 0,\n      A == 0 ~ H_A\n    )\n  )\n\n\nIPWによるATE\n\n\\[\nATE_{ipw} = {\\mathrm E}[\\frac{A}{\\mathrm{Pr}(A = 1 | W)}Y - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)}Y]\n\\]\n\ndat_tmle2 |&gt; \n  summarise(CFmean = sum(Y*ipw) / sum(ipw), .by = A) |&gt; \n  arrange(A) |&gt; \n  summarise(ATE = diff(CFmean))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.298\n\n\n\nAugumented IPWによるATE\n\n（ほんとは関数推定時にcross-fitをする）\n\n\n\\[\nATE_{aipw} = \\mathrm E[\\mathrm E[Y | A := 1, W] - \\mathrm E[Y | A := 0, W] + \\frac{A}{\\mathrm Pr(A = 1 | W)}(Y - {\\mathrm E}[Y | A := 1, W]) - \\frac{1 - A}{1 - \\mathrm Pr(A = 1 | W)}(Y - \\mathrm E[Y | A := 0, W])]\n\\]\n\ndat_tmle2 |&gt; \n  summarise(ATE = mean(Q_A1 - Q_A0 + ipw*A*(Y - Q_A1) - ipw*(1 - A)*(Y - Q_A0)))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300\n\n\n\n\n\n\n\nAIPWの問題点：統計的最適化がターゲットのパラメータ（ATE）に対してではなく、母平均関数\\({\\mathrm E}[Y | A,W]\\)および傾向スコア関数\\(\\mathrm{Pr}(A = 1 | W)\\)のパラメータについて最適化されている点\n推定したいパラメータ（ATE）のEIF（Efficient Influence Function）を解くことがこのステップのポイントらしい\n具体的には、Step1で推定した\\(\\mathrm{E}[Y | A, W]\\)と、Step2で推定したClever Covariate\\(H(A, W)\\)を用いて、以下の回帰式の\\(\\epsilon\\)（変動パラメータ）を推定する\n\n\\[\nY = \\mathrm{E}[Y | A, W] + \\epsilon H(A,W)\n\\]\n\n切片が0で、Step1の推定値の係数を1に固定するために、-1とoffsetを利用する\n\n\nfit &lt;- glm(Y ~ -1 + offset(Q_A) + H_A, data = dat_tmle2, family = gaussian())\n\n\n変動パラメータの推定値\n\n\nepsilon &lt;- coef(fit)\n\nepsilon\n\n        H_A \n6.40031e-07 \n\n\n\n\n\n\n推定したepsilonと\\(Y\\)の予測値をもとに、\\(Y\\)の予測値を更新\n\n\ndat_tmle3 &lt;- \n  dat_tmle2 |&gt; \n  mutate(\n    Q_A_update = Q_A + epsilon*H_A,\n    Q_A1_update = Q_A1 + epsilon*H_A1,\n    Q_A0_update = Q_A0 + epsilon*H_A0,\n  )\n\n\n\n\n\n更新されたアウトカムの予測値を用いて、Standardizationの要領でATEを推定\n\n\ndat_tmle3 |&gt; \n  summarise(ATE = mean(Q_A1_update - Q_A0_update))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300\n\nATE &lt;- mean(dat_tmle3$Q_A1_update - dat_tmle3$Q_A0_update)\n\n\n\n\n\nTMLEではbootstrapによらずとも標準誤差を算出できる（！）\nまずは、Influence Functionを推定する\nInfluence Function：各サンプルがどれだけATEに影響をあたえるか？\n\n\ndat_tmle4 &lt;- \n  dat_tmle3 |&gt; \n  mutate(\n    IF = (Y - Q_A_update)*H_A + Q_A1_update - Q_A0_update - ATE\n  )\n\nATEの標準誤差はIFを用いて\n\\[\nSE = \\sqrt{\\frac{\\mathrm{var}(IF)}{N}}\n\\]\n\ndat_tmle4 |&gt; \n  summarise(SE = sqrt(var(IF) / 1000))\n\n# A tibble: 1 × 1\n         SE\n      &lt;dbl&gt;\n1 0.0000217"
  },
  {
    "objectID": "blog/posts/TMLE.html#下準備",
    "href": "blog/posts/TMLE.html#下準備",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "library(tidyverse)\nlibrary(sl3)\nlibrary(tmle3)\nlibrary(future)\n\nkable &lt;- partial(\n  knitr::kable,\n  digits = 3\n)\n\nplan(multisession, workers = 8)\n\nset.seed(7)\n\n\n\n\n\n元のサイトでは\\(Y\\)が2値変数になっていて、推定が真値と一致しているかどうかの評価が難しいので、ここでは\\(Y\\)を連続変数としている。\nATEの真値は0.3に設定\n\n\ngenerate_data &lt;- function(n){ \n    W1 &lt;- rbinom(n, size=1, prob=0.2) # binary confounder\n    W2 &lt;- rbinom(n, size=1, prob=0.5) # binary confounder\n    W3 &lt;- round(runif(n, min=2, max=7)) # continuous confounder\n    W4 &lt;- round(runif(n, min=0, max=4)) # continuous confounder\n    A  &lt;- rbinom(n, size=1, prob= plogis(-0.2 + 0.2*W2 + log(0.1*W3) + 0.3*W4 + 0.2*W1*W4)) # binary treatment depends on confounders\n    Y &lt;- -1 + 0.3*A - 0.1*W1 + 0.2*W2 + 0.3*W3 - 0.1*W4 + sin(0.1*W2*W4) # continuous outcome depends on confounders\n    return(tibble(Y, W1, W2, W3, W4, A))\n}\n\nn &lt;- 1000\ndat_obs &lt;- generate_data(n) # generate a data set with n observations\n\n\ndat_obs |&gt; \n  summarise(samplemean = mean(Y), .by = A)\n\n# A tibble: 2 × 2\n      A samplemean\n  &lt;int&gt;      &lt;dbl&gt;\n1     1      0.686\n2     0      0.237\n\n\n\n\n\n\nglm、Lasso、Random forest、Multivariate adaptive regression splineをスタッキング\n\n\nsl_libs &lt;-\n  Lrnr_sl$new(\n    learners = Stack$new(\n      Lrnr_glm$new(), \n      Lrnr_glmnet$new(alpha = 1), \n      Lrnr_ranger$new(num.trees = 2000, max.depth = 3), \n      Lrnr_earth$new()\n    )\n  )"
  },
  {
    "objectID": "blog/posts/TMLE.html#step1アウトカムの予測",
    "href": "blog/posts/TMLE.html#step1アウトカムの予測",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "\\[\n{\\mathrm E}[Y | A, W]\n\\]\n\ntask &lt;- \n  sl3_Task$new(\n    dat_obs, \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\ntask_A1 &lt;- \n  sl3_Task$new(\n    dat_obs |&gt; mutate(A = 1), \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\ntask_A0 &lt;- \n  sl3_Task$new(\n    dat_obs |&gt; mutate(A = 0), \n    covariates = select(dat_obs, !Y) |&gt; names(), \n    outcome = 'Y', \n    outcome_type = 'continuous', \n    folds = 8L\n  )\n\n# 全サンプルで学習\nsl_fit &lt;- sl_libs$train(task)\n\n\n以下の3つの予測値を算出\n\\(A := 1\\)は全サンプルでAを1にする（\\(A = 1\\)はサンプルのうちのAが1となる部分集団）\n\n\\[\\begin{align}\n&{\\mathrm E}[Y | A, W] \\\\\n&{\\mathrm E}[Y | A := 1, W] \\\\\n&{\\mathrm E}[Y | A := 0, W]\n\\end{align}\\]\n\ndat_tmle1 &lt;- \n  dat_obs |&gt; \n  mutate(\n    # 観測サンプルについての予測値\n    Q_A = sl_fit$predict(task),\n    # 全てのサンプルでA = 1に固定したときの予測値\n    Q_A1 = sl_fit$predict(task_A1),\n    # 全てのサンプルでA = 0に固定した時の予測値\n    Q_A0 = sl_fit$predict(task_A0)\n  )\n\n\nstandardization（g-computation）によるATE\n\n\\[\nATE_{g \\mathrm{-}comp} = {\\mathrm E}[ {\\mathrm E}[Y | A := 1, W] - {\\mathrm E}[Y | A := 0, W]]\n\\]\n\ndat_tmle1 |&gt; \n  summarise(ATE = mean(Q_A1 - Q_A0))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300"
  },
  {
    "objectID": "blog/posts/TMLE.html#step2処置確率傾向スコアの予測",
    "href": "blog/posts/TMLE.html#step2処置確率傾向スコアの予測",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "傾向スコアを機械学習モデルにより予測\n\n\\[\n\\mathrm{Pr}(A = 1 | W)\n\\]\n\ntask_g &lt;- \n  sl3_Task$new(\n    data = dat_obs, \n    covariates = select(dat_obs, !c(Y, A)) |&gt; names(), \n    outcome = 'A', \n    outcome_type = 'binomial', \n    folds = 8\n  )\n\nsl_fit_g &lt;- sl_libs$train(task_g)\n\n\n\n\n傾向スコアからClever Covariateと呼ばれる情報を作成（IPWに似ている）\n\n\\[\\begin{align}\n&H(A,W) &= \\frac{A}{\\mathrm{Pr}(A = 1 | W)} - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)} \\\\\n&H(1,W) &= \\frac{A}{\\mathrm{Pr}(A = 1 | W)} \\\\\n&H(0,W) &= - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)}\n\\end{align}\\]\n\ndat_tmle2 &lt;- \n  dat_tmle1 |&gt; \n  mutate(\n    # Propensity Scoreの予測\n    ps = sl_fit_g$predict(task_g),\n    # ipw (Inverse Probability Weight)\n    ipw = case_when(\n      A == 1 ~ 1 / ps, \n      A == 0 ~ 1 / (1 - ps)\n    ),\n    # Clever Covariates\n    H_A = case_when(\n      A == 1 ~ 1 / ps,\n      A == 0 ~ -1 / (1 - ps)\n    ),\n    H_A1 = case_when(\n      A == 1 ~ H_A,\n      A == 0 ~ 0\n    ),\n    H_A0 = case_when(\n      A == 1 ~ 0,\n      A == 0 ~ H_A\n    )\n  )\n\n\nIPWによるATE\n\n\\[\nATE_{ipw} = {\\mathrm E}[\\frac{A}{\\mathrm{Pr}(A = 1 | W)}Y - \\frac{1 - A}{1 - \\mathrm{Pr}(A = 1 | W)}Y]\n\\]\n\ndat_tmle2 |&gt; \n  summarise(CFmean = sum(Y*ipw) / sum(ipw), .by = A) |&gt; \n  arrange(A) |&gt; \n  summarise(ATE = diff(CFmean))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.298\n\n\n\nAugumented IPWによるATE\n\n（ほんとは関数推定時にcross-fitをする）\n\n\n\\[\nATE_{aipw} = \\mathrm E[\\mathrm E[Y | A := 1, W] - \\mathrm E[Y | A := 0, W] + \\frac{A}{\\mathrm Pr(A = 1 | W)}(Y - {\\mathrm E}[Y | A := 1, W]) - \\frac{1 - A}{1 - \\mathrm Pr(A = 1 | W)}(Y - \\mathrm E[Y | A := 0, W])]\n\\]\n\ndat_tmle2 |&gt; \n  summarise(ATE = mean(Q_A1 - Q_A0 + ipw*A*(Y - Q_A1) - ipw*(1 - A)*(Y - Q_A0)))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300"
  },
  {
    "objectID": "blog/posts/TMLE.html#step3変動パラメータの推定",
    "href": "blog/posts/TMLE.html#step3変動パラメータの推定",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "AIPWの問題点：統計的最適化がターゲットのパラメータ（ATE）に対してではなく、母平均関数\\({\\mathrm E}[Y | A,W]\\)および傾向スコア関数\\(\\mathrm{Pr}(A = 1 | W)\\)のパラメータについて最適化されている点\n推定したいパラメータ（ATE）のEIF（Efficient Influence Function）を解くことがこのステップのポイントらしい\n具体的には、Step1で推定した\\(\\mathrm{E}[Y | A, W]\\)と、Step2で推定したClever Covariate\\(H(A, W)\\)を用いて、以下の回帰式の\\(\\epsilon\\)（変動パラメータ）を推定する\n\n\\[\nY = \\mathrm{E}[Y | A, W] + \\epsilon H(A,W)\n\\]\n\n切片が0で、Step1の推定値の係数を1に固定するために、-1とoffsetを利用する\n\n\nfit &lt;- glm(Y ~ -1 + offset(Q_A) + H_A, data = dat_tmle2, family = gaussian())\n\n\n変動パラメータの推定値\n\n\nepsilon &lt;- coef(fit)\n\nepsilon\n\n        H_A \n6.40031e-07"
  },
  {
    "objectID": "blog/posts/TMLE.html#step4アウトカムの予測値を更新",
    "href": "blog/posts/TMLE.html#step4アウトカムの予測値を更新",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "推定したepsilonと\\(Y\\)の予測値をもとに、\\(Y\\)の予測値を更新\n\n\ndat_tmle3 &lt;- \n  dat_tmle2 |&gt; \n  mutate(\n    Q_A_update = Q_A + epsilon*H_A,\n    Q_A1_update = Q_A1 + epsilon*H_A1,\n    Q_A0_update = Q_A0 + epsilon*H_A0,\n  )"
  },
  {
    "objectID": "blog/posts/TMLE.html#step5推定したい統計量を推定",
    "href": "blog/posts/TMLE.html#step5推定したい統計量を推定",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "更新されたアウトカムの予測値を用いて、Standardizationの要領でATEを推定\n\n\ndat_tmle3 |&gt; \n  summarise(ATE = mean(Q_A1_update - Q_A0_update))\n\n# A tibble: 1 × 1\n    ATE\n  &lt;dbl&gt;\n1 0.300\n\nATE &lt;- mean(dat_tmle3$Q_A1_update - dat_tmle3$Q_A0_update)"
  },
  {
    "objectID": "blog/posts/TMLE.html#step6標準誤差の推定",
    "href": "blog/posts/TMLE.html#step6標準誤差の推定",
    "title": "Targeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)",
    "section": "",
    "text": "TMLEではbootstrapによらずとも標準誤差を算出できる（！）\nまずは、Influence Functionを推定する\nInfluence Function：各サンプルがどれだけATEに影響をあたえるか？\n\n\ndat_tmle4 &lt;- \n  dat_tmle3 |&gt; \n  mutate(\n    IF = (Y - Q_A_update)*H_A + Q_A1_update - Q_A0_update - ATE\n  )\n\nATEの標準誤差はIFを用いて\n\\[\nSE = \\sqrt{\\frac{\\mathrm{var}(IF)}{N}}\n\\]\n\ndat_tmle4 |&gt; \n  summarise(SE = sqrt(var(IF) / 1000))\n\n# A tibble: 1 × 1\n         SE\n      &lt;dbl&gt;\n1 0.0000217"
  },
  {
    "objectID": "blog/posts/multi_answer.html",
    "href": "blog/posts/multi_answer.html",
    "title": "マルチアンサーの処理",
    "section": "",
    "text": "library(tidyverse)"
  },
  {
    "objectID": "blog/posts/multi_answer.html#パッケージ",
    "href": "blog/posts/multi_answer.html#パッケージ",
    "title": "マルチアンサーの処理",
    "section": "",
    "text": "library(tidyverse)"
  },
  {
    "objectID": "blog/posts/multi_answer.html#googleフォームなどのマルチアンサーの処理",
    "href": "blog/posts/multi_answer.html#googleフォームなどのマルチアンサーの処理",
    "title": "マルチアンサーの処理",
    "section": "Googleフォームなどのマルチアンサーの処理",
    "text": "Googleフォームなどのマルチアンサーの処理\ngoogleフォームでマルチアンサー形式の設問を作ると、以下のようにカンマで区切られた形式でデータが入力される。\n\ndata &lt;- \n  tibble(\n    q1 = c('A,B,C', 'A,B', 'A,C', 'B,C', 'A', 'B', 'C'),\n  ) |&gt; \n  mutate(id = row_number()) |&gt; \n  relocate(id, .before = q1) \n\ndata\n\n# A tibble: 7 × 2\n     id q1   \n  &lt;int&gt; &lt;chr&gt;\n1     1 A,B,C\n2     2 A,B  \n3     3 A,C  \n4     4 B,C  \n5     5 A    \n6     6 B    \n7     7 C    \n\n\nまずはカンマで区切られているやつを分割する。\n\ndata |&gt; \n  separate_longer_delim(cols = q1, delim = ',') \n\n# A tibble: 12 × 2\n      id q1   \n   &lt;int&gt; &lt;chr&gt;\n 1     1 A    \n 2     1 B    \n 3     1 C    \n 4     2 A    \n 5     2 B    \n 6     3 A    \n 7     3 C    \n 8     4 B    \n 9     4 C    \n10     5 A    \n11     6 B    \n12     7 C    \n\n\nこのデータの意味自体は、id:1はA,B,Cを選択した、というものである。\nなのでフラグとして1を立てておく。\n\ndata |&gt; \n  separate_longer_delim(cols = q1, delim = ',') |&gt;\n  mutate(flag = 1)\n\n# A tibble: 12 × 3\n      id q1     flag\n   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n 1     1 A         1\n 2     1 B         1\n 3     1 C         1\n 4     2 A         1\n 5     2 B         1\n 6     3 A         1\n 7     3 C         1\n 8     4 B         1\n 9     4 C         1\n10     5 A         1\n11     6 B         1\n12     7 C         1\n\n\nつぎにこれを横持ちに展開する。\n\ndata |&gt; \n  separate_longer_delim(cols = q1, delim = ',') |&gt;\n  mutate(flag = 1) |&gt; \n  pivot_wider(names_from = q1, values_from = flag)\n\n# A tibble: 7 × 4\n     id     A     B     C\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1     1     1\n2     2     1     1    NA\n3     3     1    NA     1\n4     4    NA     1     1\n5     5     1    NA    NA\n6     6    NA     1    NA\n7     7    NA    NA     1\n\n\nこれで、A,B,Cの選択状況がわかるようになった。\n非選択がNAになっているのは少々アレなので、0で埋めるようにする。\n\ndata |&gt; \n  separate_longer_delim(cols = q1, delim = ',') |&gt;\n  mutate(flag = 1) |&gt; \n  pivot_wider(names_from = q1, values_from = flag, values_fill = 0)\n\n# A tibble: 7 × 4\n     id     A     B     C\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1     1     1\n2     2     1     1     0\n3     3     1     0     1\n4     4     0     1     1\n5     5     1     0     0\n6     6     0     1     0\n7     7     0     0     1\n\n\nこれでダミー変数に変換できた。\nもともとの変数名であるq1が消えてしまっているので、それを残すにはnames_prefixを指定する。\n\ndata |&gt; \n  separate_longer_delim(cols = q1, delim = ',') |&gt;\n  mutate(flag = 1) |&gt; \n  pivot_wider(\n    names_from = q1, \n    names_prefix = 'q1_', \n    values_from = flag, \n    values_fill = 0\n  ) \n\n# A tibble: 7 × 4\n     id  q1_A  q1_B  q1_C\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1     1     1\n2     2     1     1     0\n3     3     1     0     1\n4     4     0     1     1\n5     5     1     0     0\n6     6     0     1     0\n7     7     0     0     1"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html",
    "href": "blog/posts/Causal_Decomposition.html",
    "title": "Causal Decomposition Analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(cfdecomp)\nlibrary(gapclosing)\nlibrary(causal.decomp)\n\n\nd &lt;- \n  sMIDUS |&gt; \n  transmute(Y = health |&gt; as.numeric(),  # outcome\n            T = edu |&gt; as.numeric(),   # treatment (continuous)\n            T2 = edu |&gt; case_match(4:6 ~ 0,   # treatment (binary)\n                                   7:9 ~ 1,\n                                   .default = NA) |&gt; factor(),\n            X = racesex |&gt; factor(levels = c(\"1\", \"4\", \"2\", \"3\")),  # note!\n            L1 = lowchildSES |&gt; as.numeric(),\n            L2 = abuse |&gt; as.numeric(),\n            C1 = age |&gt; as.numeric(),\n            C2 = stroke |&gt; as.numeric(),\n            C3 = T2DM |&gt; as.numeric(),\n            C4 = heart |&gt; as.numeric()) |&gt; \n  mutate(across(L1:C4, \\(.x){.x - mean(.x, na.rm = TRUE)})) |&gt; \n  tibble()"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#前準備",
    "href": "blog/posts/Causal_Decomposition.html#前準備",
    "title": "Causal Decomposition Analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(cfdecomp)\nlibrary(gapclosing)\nlibrary(causal.decomp)\n\n\nd &lt;- \n  sMIDUS |&gt; \n  transmute(Y = health |&gt; as.numeric(),  # outcome\n            T = edu |&gt; as.numeric(),   # treatment (continuous)\n            T2 = edu |&gt; case_match(4:6 ~ 0,   # treatment (binary)\n                                   7:9 ~ 1,\n                                   .default = NA) |&gt; factor(),\n            X = racesex |&gt; factor(levels = c(\"1\", \"4\", \"2\", \"3\")),  # note!\n            L1 = lowchildSES |&gt; as.numeric(),\n            L2 = abuse |&gt; as.numeric(),\n            C1 = age |&gt; as.numeric(),\n            C2 = stroke |&gt; as.numeric(),\n            C3 = T2DM |&gt; as.numeric(),\n            C4 = heart |&gt; as.numeric()) |&gt; \n  mutate(across(L1:C4, \\(.x){.x - mean(.x, na.rm = TRUE)})) |&gt; \n  tibble()"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#cfdecomp",
    "href": "blog/posts/Causal_Decomposition.html#cfdecomp",
    "title": "Causal Decomposition Analysis",
    "section": "cfdecomp",
    "text": "cfdecomp\n\nSudharsanan and Bijlsma (2021) の方法。mediatorの値をシミュレーションで複数生成するのが特徴\n\n\n# cfd.mean\nfit_cfdecomp &lt;-\n  cfdecomp::cfd.mean(\n    formula.y = 'Y ~ X + T + X:T + L1 + L2 + C1 + C2 + C3 + C4',\n    formula.m = 'T ~ X + C1 + C2 + C3 + C4',\n    mediator = 'T',\n    group = 'X',\n    data = d |&gt; data.frame(),\n    family.y = 'gaussian',\n    family.m = 'gaussian',\n    bs.size = 50,\n    mc.size = 10,\n    alpha = 0.05\n  )\n\n\nfit_cfdecomp\n\n$out_nc_m\n          1        4        2        3\n1  7.691620 5.903479 7.074230 6.401085\n2  7.686288 5.851340 7.093282 6.399524\n3  7.708576 5.822106 7.094568 6.384855\n4  7.705292 5.868466 7.076435 6.338724\n5  7.719214 5.913302 7.105034 6.404542\n6  7.684584 5.926160 7.049353 6.326670\n7  7.710585 5.882988 7.095104 6.348387\n8  7.679686 5.899821 7.080776 6.470807\n9  7.725260 5.935738 7.066875 6.447876\n10 7.680137 5.857691 7.054819 6.373660\n11 7.696426 5.944271 7.063720 6.439212\n12 7.700643 5.821413 7.085500 6.339201\n13 7.693362 5.846745 7.088152 6.419090\n14 7.716584 5.850613 7.101872 6.458169\n15 7.712684 5.885706 7.060460 6.404721\n16 7.704699 5.920647 7.072777 6.446932\n17 7.700979 5.886535 7.092668 6.414058\n18 7.665549 5.913848 7.109964 6.392970\n19 7.705040 5.812203 7.083783 6.460505\n20 7.717075 5.893334 7.062888 6.438355\n21 7.717534 5.932667 7.080653 6.412771\n22 7.726708 5.833179 7.058449 6.382606\n23 7.747496 5.888901 7.102890 6.391513\n24 7.736253 5.871866 7.082152 6.349239\n25 7.711726 5.870103 7.117876 6.472197\n26 7.723777 5.882988 7.103639 6.326517\n27 7.672843 5.795129 7.071731 6.481404\n28 7.733062 5.842725 7.075069 6.374337\n29 7.692945 5.859889 7.097161 6.433527\n30 7.717666 5.927108 7.091016 6.366568\n31 7.691101 5.852563 7.113142 6.415854\n32 7.697604 5.831029 7.105097 6.367603\n33 7.741424 5.902711 7.105534 6.331117\n34 7.722045 5.784367 7.103666 6.437032\n35 7.692453 5.862954 7.076089 6.321857\n36 7.646706 5.809606 7.062814 6.383445\n37 7.705667 5.860735 7.041463 6.436072\n38 7.699599 5.809260 7.071437 6.413898\n39 7.713365 5.884598 7.065502 6.334899\n40 7.697805 5.904221 7.088727 6.410220\n41 7.701732 5.853243 7.068522 6.428324\n42 7.712378 5.929001 7.090080 6.437932\n43 7.712444 5.837593 7.074545 6.392852\n44 7.745429 5.907289 7.060106 6.432842\n45 7.744076 5.882094 7.077142 6.328885\n46 7.701634 5.856016 7.061101 6.394278\n47 7.688703 5.866987 7.051684 6.389235\n48 7.693028 5.872492 7.063328 6.418712\n49 7.678176 5.854286 7.047194 6.379773\n50 7.693541 5.946907 7.042778 6.365255\n\n$out_cf_m\n          1        4        2        3\n1  7.694368 7.706683 7.711569 7.676656\n2  7.675996 7.709028 7.680850 7.684987\n3  7.693016 7.706211 7.713118 7.695313\n4  7.712819 7.707977 7.719926 7.675929\n5  7.699568 7.711089 7.699306 7.688434\n6  7.698347 7.667810 7.701188 7.671001\n7  7.708082 7.725790 7.716572 7.713793\n8  7.682451 7.700808 7.692263 7.667218\n9  7.726994 7.725572 7.731699 7.717573\n10 7.708675 7.724889 7.705377 7.671621\n11 7.691167 7.701819 7.708740 7.677413\n12 7.706299 7.723064 7.730158 7.696099\n13 7.693928 7.709600 7.707202 7.684103\n14 7.710371 7.730474 7.717734 7.704569\n15 7.723861 7.719707 7.735832 7.736501\n16 7.705975 7.739768 7.723184 7.681721\n17 7.711067 7.708167 7.718204 7.696593\n18 7.666730 7.682081 7.667588 7.702620\n19 7.694994 7.686376 7.706852 7.692542\n20 7.712226 7.708470 7.715184 7.703222\n21 7.714746 7.739595 7.738355 7.728673\n22 7.713479 7.742127 7.728872 7.731431\n23 7.742325 7.735250 7.751190 7.717709\n24 7.740702 7.738517 7.771374 7.717973\n25 7.710550 7.697311 7.728057 7.727471\n26 7.711095 7.748652 7.731093 7.683119\n27 7.661539 7.659760 7.677740 7.644783\n28 7.722719 7.773671 7.733193 7.710887\n29 7.694222 7.713420 7.724826 7.735735\n30 7.708394 7.711895 7.728228 7.735981\n31 7.693792 7.712127 7.677894 7.654353\n32 7.698869 7.707765 7.722551 7.711125\n33 7.727526 7.729553 7.725879 7.712680\n34 7.736907 7.734511 7.747580 7.737776\n35 7.688590 7.689720 7.699519 7.677718\n36 7.651915 7.661290 7.659749 7.684469\n37 7.713434 7.709630 7.715647 7.705886\n38 7.700683 7.694580 7.687552 7.653711\n39 7.716684 7.709416 7.717984 7.643918\n40 7.678471 7.716327 7.727294 7.698329\n41 7.693627 7.704902 7.707023 7.703769\n42 7.704315 7.742958 7.713615 7.659216\n43 7.713094 7.717394 7.707769 7.671835\n44 7.750917 7.762555 7.744067 7.728395\n45 7.751429 7.758673 7.756817 7.725800\n46 7.700168 7.722584 7.718004 7.667568\n47 7.699436 7.706097 7.714158 7.680908\n48 7.684891 7.672446 7.679650 7.667766\n49 7.676596 7.678788 7.710157 7.650747\n50 7.696234 7.682737 7.688559 7.668339\n\n$out_nc_quantile_m\n             1        4        2        3\n2.5%  7.667190 5.798309 7.043772 6.326551\n50%   7.704870 5.870985 7.076789 6.400304\n97.5% 7.745125 5.942351 7.112427 6.471884\n\n$out_cf_quantile_m\n             1        4        2        3\n2.5%  7.662707 7.662757 7.669873 7.646125\n50%   7.705145 7.710360 7.716109 7.693927\n97.5% 7.748984 7.761681 7.755551 7.736384\n\n$out_nc_y\n          1        4        2        3\n1  7.573016 6.752405 7.321271 7.061268\n2  7.634295 6.726107 7.322181 6.949904\n3  7.586864 6.680242 7.363882 6.883184\n4  7.609331 6.727532 7.326431 6.810922\n5  7.595753 6.766591 7.308360 7.071568\n6  7.607702 6.684720 7.325853 6.854390\n7  7.599817 6.703397 7.307502 6.882905\n8  7.592916 6.718701 7.324578 6.920241\n9  7.561821 6.795550 7.285833 7.081418\n10 7.587595 6.667228 7.296214 6.964471\n11 7.629020 6.749562 7.345921 6.932641\n12 7.605666 6.716479 7.304525 6.962370\n13 7.615934 6.779819 7.336255 6.937528\n14 7.599271 6.689468 7.324713 7.049985\n15 7.593428 6.738799 7.292353 7.018741\n16 7.640615 6.670906 7.324079 6.936599\n17 7.573441 6.802899 7.367897 7.026279\n18 7.607972 6.680871 7.331547 6.987752\n19 7.595871 6.614606 7.350704 7.067088\n20 7.595863 6.731565 7.359684 7.014888\n21 7.615533 6.665645 7.298754 7.071895\n22 7.610810 6.680488 7.273439 7.017883\n23 7.611379 6.620520 7.350792 6.942568\n24 7.558913 6.697029 7.330005 6.941346\n25 7.626489 6.712025 7.379597 7.058167\n26 7.619216 6.697429 7.302447 6.985057\n27 7.612853 6.650963 7.342401 7.034549\n28 7.629465 6.736374 7.323146 6.999512\n29 7.598120 6.637056 7.352217 6.910594\n30 7.558746 6.658438 7.303486 7.009547\n31 7.574483 6.703021 7.302062 6.993343\n32 7.579724 6.781071 7.356608 6.994657\n33 7.592171 6.721632 7.317557 6.949315\n34 7.621765 6.664997 7.320297 7.046020\n35 7.613701 6.666155 7.349768 6.976570\n36 7.602946 6.678714 7.333877 7.011596\n37 7.599440 6.790371 7.286552 7.069060\n38 7.574340 6.704108 7.367429 6.855076\n39 7.645508 6.701465 7.313479 6.939002\n40 7.603820 6.729732 7.381661 7.017929\n41 7.605537 6.687921 7.310661 6.953378\n42 7.593308 6.793165 7.318804 7.059395\n43 7.610781 6.634967 7.338410 6.976505\n44 7.616556 6.651578 7.311554 6.974912\n45 7.632992 6.720921 7.352840 7.006610\n46 7.617324 6.661013 7.270648 6.882098\n47 7.574085 6.696714 7.321917 7.054938\n48 7.599348 6.711412 7.340888 6.957741\n49 7.592058 6.653166 7.320236 6.870126\n50 7.589620 6.693150 7.326758 6.944336\n\n$out_cf_y\n          1        4        2        3\n1  7.573730 7.240279 7.482160 7.302499\n2  7.631680 7.368768 7.474985 7.113000\n3  7.582978 7.260099 7.512674 7.231814\n4  7.611341 7.411821 7.452879 7.253369\n5  7.590240 7.346065 7.411637 7.605579\n6  7.610949 7.280478 7.457437 7.199937\n7  7.599172 7.361021 7.422648 7.318868\n8  7.593424 7.248864 7.479899 7.262653\n9  7.562247 7.409231 7.464533 7.197400\n10 7.593578 7.179452 7.441228 7.090939\n11 7.627558 7.362620 7.511612 7.145889\n12 7.606965 7.239569 7.476154 7.265005\n13 7.616101 7.294466 7.467196 7.171395\n14 7.597951 7.271881 7.479806 7.187036\n15 7.596067 7.348779 7.446468 7.199063\n16 7.640890 7.128956 7.453126 7.204143\n17 7.575415 7.366839 7.470799 7.312720\n18 7.608315 7.280738 7.498315 7.156028\n19 7.593474 7.114045 7.473989 7.315470\n20 7.594700 7.359600 7.487534 7.317045\n21 7.614798 7.246894 7.456660 7.431237\n22 7.607819 7.255252 7.444764 7.221171\n23 7.610009 7.185242 7.503252 7.349578\n24 7.560010 7.188910 7.504737 7.182100\n25 7.626224 7.259911 7.496198 7.266678\n26 7.615960 7.302600 7.433851 7.345645\n27 7.609832 7.091500 7.445738 7.337904\n28 7.626666 7.276931 7.441374 7.391370\n29 7.598436 7.254692 7.464678 7.114766\n30 7.556404 7.147611 7.459120 7.238598\n31 7.575181 7.293017 7.434385 7.150378\n32 7.580022 7.470379 7.508724 7.182596\n33 7.589021 7.403243 7.468844 7.367467\n34 7.625055 7.184854 7.458165 7.168135\n35 7.612651 7.162224 7.523586 7.197273\n36 7.604204 7.301450 7.475374 7.387443\n37 7.601125 7.329756 7.441788 7.224172\n38 7.574534 7.137476 7.493522 6.991932\n39 7.646302 7.253615 7.455726 7.440136\n40 7.598518 7.248932 7.545624 7.248419\n41 7.603452 7.297836 7.453622 7.278437\n42 7.591664 7.354226 7.452288 7.333391\n43 7.610948 7.133287 7.472096 7.216578\n44 7.617624 7.170186 7.461299 7.154297\n45 7.634294 7.382895 7.469423 7.244824\n46 7.616935 7.333921 7.453229 7.300790\n47 7.576508 7.242801 7.427903 7.369563\n48 7.597225 7.280241 7.481485 7.226395\n49 7.591651 7.161913 7.471343 7.308058\n50 7.590347 7.261708 7.471020 7.125801\n\n$out_nc_quantile_y\n             1        4        2        3\n2.5%  7.559567 6.623770 7.276227 6.854545\n50%   7.601382 6.699447 7.324329 6.980813\n97.5% 7.639193 6.795013 7.376964 7.071822\n\n$out_cf_quantile_y\n             1        4        2        3\n2.5%  7.560513 7.117400 7.423830 7.095903\n50%   7.600148 7.266794 7.468020 7.241711\n97.5% 7.639406 7.411239 7.521131 7.438134\n\n$mediation\n        4         2         3 \n0.6333258 0.5223352 0.4399892 \n\n$mediation_quantile\n              4         2         3\n2.5%  0.4781255 0.3829605 0.2050149\n97.5% 0.7968414 0.7253825 0.6984420\n\n$mc_conv_info_m\n          [,1]     [,2]     [,3]     [,4]\n [1,] 7.723979 5.860656 7.069235 6.433601\n [2,] 7.700368 5.910926 7.087214 6.426046\n [3,] 7.707292 5.897989 7.082427 6.420352\n [4,] 7.705495 5.907370 7.079774 6.421104\n [5,] 7.703893 5.905221 7.078589 6.414830\n [6,] 7.702086 5.908586 7.077403 6.387218\n [7,] 7.696097 5.903654 7.077836 6.390850\n [8,] 7.692815 5.898737 7.075043 6.394151\n [9,] 7.691646 5.899766 7.075412 6.392675\n[10,] 7.691620 5.903479 7.074230 6.401085\n\n$mc_conv_info_y\n          [,1]     [,2]     [,3]     [,4]\n [1,] 7.581415 6.740819 7.320010 7.067418\n [2,] 7.575287 6.754420 7.324549 7.065989\n [3,] 7.577084 6.750919 7.323340 7.064912\n [4,] 7.576617 6.753458 7.322670 7.065054\n [5,] 7.576202 6.752876 7.322371 7.063868\n [6,] 7.575733 6.753787 7.322072 7.058646\n [7,] 7.574178 6.752452 7.322181 7.059333\n [8,] 7.573327 6.751122 7.321476 7.059957\n [9,] 7.573023 6.751400 7.321569 7.059678\n[10,] 7.573016 6.752405 7.321271 7.061268\n\nmean(fit_cfdecomp$out_nc_y[,2] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.8977706\n\nmean(fit_cfdecomp$out_cf_y[,2] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.3320029\n\nmean(fit_cfdecomp$out_nc_y[,2] - fit_cfdecomp$out_cf_y[,2])\n\n[1] -0.5657677\n\nfit_cfdecomp$mediation\n\n        4         2         3 \n0.6333258 0.5223352 0.4399892 \n\nmean(fit_cfdecomp$out_nc_y[,3] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.2753829\n\nmean(fit_cfdecomp$out_cf_y[,3] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.1330466\n\nmean(fit_cfdecomp$out_nc_y[,3] - fit_cfdecomp$out_cf_y[,3])\n\n[1] -0.1423364\n\nmean(fit_cfdecomp$out_nc_y[,4] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.623387\n\nmean(fit_cfdecomp$out_cf_y[,4] - fit_cfdecomp$out_nc_y[,1])\n\n[1] -0.3488448\n\nmean(fit_cfdecomp$out_nc_y[,4] - fit_cfdecomp$out_cf_y[,4])\n\n[1] -0.2745423"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#causal.decomp",
    "href": "blog/posts/Causal_Decomposition.html#causal.decomp",
    "title": "Causal Decomposition Analysis",
    "section": "causal.decomp",
    "text": "causal.decomp\n\n(Park2023a?) の方法。\n\n\n# smi \nfit.y &lt;- lm(Y ~ X + T + X:T + L1 + L2 + C1 + C2 + C3 + C4, data = d)\nfit.m &lt;- lm(T ~ X + C1 + C2 + C3 + C4, data = d)\n\nfit_smi &lt;- smi(fit.y = fit.y,\n    fit.m = fit.m,\n    treat = \"X\", \n    sims = 100, \n    conf.level = .95,\n    conditional = TRUE,\n    covariates = 1,\n    # baseline covariatesを調整できる\n    #covariates = c(\"C1\", \"C2\", \"C3\", \"C4\"),\n    seed = 227,\n    )\n\nfit_smi\n\n\nResults:\n\n                               estimate 95% CI Lower 95% CI Upper\nInitial Disparity   (1 vs 4) -0.8993401   -0.9925190  -0.79813505\nDisparity Remaining (1 vs 4) -0.3384430   -0.4880863  -0.14795873\nDisparity Reduction (1 vs 4) -0.5608971   -0.7346168  -0.42650061\nInitial Disparity   (1 vs 2) -0.2749659   -0.3378874  -0.19366549\nDisparity Remaining (1 vs 2) -0.1213246   -0.2203441  -0.05458727\nDisparity Reduction (1 vs 2) -0.1536412   -0.1896213  -0.10521328\nInitial Disparity   (1 vs 3) -0.6137425   -0.7326095  -0.47793913\nDisparity Remaining (1 vs 3) -0.3500123   -0.5151994  -0.08733348\nDisparity Reduction (1 vs 3) -0.2637302   -0.4880614  -0.11574038\n\n\n\nsensitivity analysis(Park et al. 2023)\n\n\nsensRes &lt;- sensitivity(boot.res = fit_smi, fit.m = fit.m, fit.y = fit.y, \n                       mediator = \"T\",\n                       covariates = c(\"C1\", \"C2\", \"C3\", \"C4\"), \n                       treat = \"X\",\n                       sel.lev.treat = \"4\", \n                       max.rsq = 0.3)\nplot(sensRes)"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#cfdecomp-1",
    "href": "blog/posts/Causal_Decomposition.html#cfdecomp-1",
    "title": "Causal Decomposition Analysis",
    "section": "cfdecomp",
    "text": "cfdecomp\n\n# cfd.mean\nset.seed(123456)\nfit_cfdecomp_b &lt;-\n  cfd.mean(\n    formula.y = 'Y ~ X + T2 + X:T2 + L1 + L2 + C1 + C2 + C3 + C4',\n    formula.m = 'T2 ~ X + C1 + C2 + C3 + C4',\n    mediator = 'T2',\n    group = 'X',\n    data = d |&gt; mutate(T2 = as.numeric(T2) - 1) |&gt; data.frame(),\n    family.y = 'gaussian',\n    family.m = 'binomial',\n    bs.size = 50,\n    mc.size = 10,\n    alpha = 0.05\n  )\nmean(fit_cfdecomp_b$out_nc_y[,\"4\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.8981701\n\nmean(fit_cfdecomp_b$out_cf_y[,\"4\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.5546351\n\nmean(fit_cfdecomp_b$out_nc_y[,\"4\"] - fit_cfdecomp_b$out_cf_y[,\"4\"])\n\n[1] -0.343535\n\nfit_cfdecomp_b$mediation\n\n        4         2         3 \n0.3828971 0.1298177 0.2061071 \n\nmean(fit_cfdecomp_b$out_nc_y[,\"2\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.2774845\n\nmean(fit_cfdecomp_b$out_cf_y[,\"2\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.2419289\n\nmean(fit_cfdecomp_b$out_nc_y[,\"2\"] - fit_cfdecomp_b$out_cf_y[,\"2\"])\n\n[1] -0.03555558\n\nmean(fit_cfdecomp_b$out_nc_y[,\"3\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.5849521\n\nmean(fit_cfdecomp_b$out_cf_y[,\"3\"] - fit_cfdecomp_b$out_nc_y[,\"1\"])\n\n[1] -0.4655888\n\nmean(fit_cfdecomp_b$out_nc_y[,\"3\"] - fit_cfdecomp_b$out_cf_y[,\"3\"])\n\n[1] -0.1193632"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#causal.decomp-1",
    "href": "blog/posts/Causal_Decomposition.html#causal.decomp-1",
    "title": "Causal Decomposition Analysis",
    "section": "causal.decomp",
    "text": "causal.decomp\n\n# smi\nfit.y &lt;- lm(Y ~ X + T2 + X:T2 + L1 + L2 + C1 + C2 + C3 + C4, data = d)\nfit.m &lt;- glm(T2 ~ X + C1 + C2 + C3 + C4, data = d, family = binomial(link = \"logit\"))\n\nfit_smi_b &lt;- smi(fit.y = fit.y,\n               fit.m = fit.m,\n               treat = \"X\", \n               sims = 100, \n               conf.level = .95,\n               conditional = TRUE,\n               # covariates = 1,\n               covariates = c(\"C1\", \"C2\", \"C3\", \"C4\"),\n               seed = 123456)\nfit_smi_b\n\n\nResults:\n\n                                estimate 95% CI Lower 95% CI Upper\nInitial Disparity   (1 vs 4) -0.95667843  -1.02938841  -0.88175003\nDisparity Remaining (1 vs 4) -0.61262729  -0.77966809  -0.46844380\nDisparity Reduction (1 vs 4) -0.34405113  -0.49650368  -0.21581205\nInitial Disparity   (1 vs 2) -0.31394841  -0.38058533  -0.26000373\nDisparity Remaining (1 vs 2) -0.27995004  -0.34624791  -0.22226331\nDisparity Reduction (1 vs 2) -0.03399837  -0.05003528  -0.02022012\nInitial Disparity   (1 vs 3) -0.59968604  -0.69525994  -0.49987857\nDisparity Remaining (1 vs 3) -0.48148718  -0.61387973  -0.32105036\nDisparity Reduction (1 vs 3) -0.11819886  -0.24676548  -0.03361808\n\nsensRes &lt;- sensitivity(boot.res = fit_smi_b, \n                       fit.m = fit.m, \n                       fit.y = fit.y, \n                       mediator = \"T2\",\n                       covariates = c(\"C1\", \"C2\", \"C3\", \"C4\"), \n                       treat = \"X\",\n                       sel.lev.treat = \"4\", \n                       max.rsq = 0.3)\nplot(sensRes)"
  },
  {
    "objectID": "blog/posts/Causal_Decomposition.html#gapclosing",
    "href": "blog/posts/Causal_Decomposition.html#gapclosing",
    "title": "Causal Decomposition Analysis",
    "section": "gapclosing",
    "text": "gapclosing\n\nLundberg (2022)\n\n\n# gapclosing - regression\n# stochastic intervention\n# treatmentの割り当て確率の予測値を算出\nfit_glm &lt;- glm(T2 ~ X + C1 + C2 + C3, data = d, family = binomial(link = \"logit\"))\n\n# 全員のtreatmentが1だった時の予測値\nassing_prob &lt;- predict(fit_glm, newdata = d |&gt; mutate(X = \"1\"), type = \"response\")\n\n# 予測値をもとにrandom draw\ndraw &lt;- rbinom(n = nrow(d), size = 1, prob = assing_prob)\n\nfit_gapclosing &lt;- \n  gapclosing(\n    data = d |&gt; mutate(T2 = as.numeric(T2) - 1),\n    outcome_formula = Y ~ T2 * X + C1 + C2 + C3 + C4 + L1 + L2,\n    treatment_name = \"T2\",\n    category_name = \"X\",\n    counterfactual_assignments = draw # random draw\n  )\n\nfit_gapclosing\n\n\nFactual mean outcomes:\n# A tibble: 4 × 2\n  X     estimate\n  &lt;fct&gt;    &lt;dbl&gt;\n1 1         7.60\n2 4         6.70\n3 2         7.32\n4 3         6.98\n\nCounterfactual mean outcomes (post-intervention means):\n# A tibble: 4 × 2\n  X     estimate\n  &lt;fct&gt;    &lt;dbl&gt;\n1 1         7.60\n2 4         7.03\n3 2         7.36\n4 3         7.11\n\nFactual disparities:\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4    0.899\n 2 1 - 2    0.275\n 3 1 - 3    0.614\n 4 4 - 1   -0.899\n 5 4 - 2   -0.624\n 6 4 - 3   -0.286\n 7 2 - 1   -0.275\n 8 2 - 4    0.624\n 9 2 - 3    0.339\n10 3 - 1   -0.614\n11 3 - 4    0.286\n12 3 - 2   -0.339\n\nCounterfactual disparities (gap-closing estimands):\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4   0.566 \n 2 1 - 2   0.241 \n 3 1 - 3   0.483 \n 4 4 - 1  -0.566 \n 5 4 - 2  -0.325 \n 6 4 - 3  -0.0830\n 7 2 - 1  -0.241 \n 8 2 - 4   0.325 \n 9 2 - 3   0.242 \n10 3 - 1  -0.483 \n11 3 - 4   0.0830\n12 3 - 2  -0.242 \n\nAdditive gap closed: Counterfactual - Factual\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4   0.334 \n 2 1 - 2   0.0339\n 3 1 - 3   0.131 \n 4 4 - 1  -0.334 \n 5 4 - 2  -0.300 \n 6 4 - 3  -0.203 \n 7 2 - 1  -0.0339\n 8 2 - 4   0.300 \n 9 2 - 3   0.0972\n10 3 - 1  -0.131 \n11 3 - 4   0.203 \n12 3 - 2  -0.0972\n\nProportional gap closed: (Counterfactual - Factual) / Factual\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4    0.371\n 2 1 - 2    0.123\n 3 1 - 3    0.214\n 4 4 - 1    0.371\n 5 4 - 2    0.480\n 6 4 - 3    0.710\n 7 2 - 1    0.123\n 8 2 - 4    0.480\n 9 2 - 3    0.287\n10 3 - 1    0.214\n11 3 - 4    0.710\n12 3 - 2    0.287\n\ndisparityplot(fit_gapclosing, category_A = \"1\", category_B = \"4\")\n\n\n\n\n\n\n\ndisparityplot(fit_gapclosing, category_A = \"1\", category_B = \"2\")\n\n\n\n\n\n\n\ndisparityplot(fit_gapclosing, category_A = \"1\", category_B = \"3\")\n\n\n\n\n\n\n\n\n\n機械学習をつかったdoubly robustな方法も使える\n\n\n# gapclosing - ranger, doubly robust\nfit_gapclosing_ranger &lt;- \n  gapclosing(\n  data = d |&gt; mutate(T2 = as.numeric(T2) - 1),\n  outcome_formula = Y ~ T2 + X + C1 + C2 + C3 + C4 + L1 + L2,\n  treatment_formula = T2 ~ X + C1 + C2 + C3 + C4 + L1 + L2, \n  treatment_name = \"T2\",\n  treatment_algorithm = \"ranger\",\n  outcome_algorithm = \"ranger\",\n  category_name = \"X\",\n  counterfactual_assignments = rbinom(n = nrow(d), size = 1, prob = assing_prob) \n)\n\nfit_gapclosing\n\n\nFactual mean outcomes:\n# A tibble: 4 × 2\n  X     estimate\n  &lt;fct&gt;    &lt;dbl&gt;\n1 1         7.60\n2 4         6.70\n3 2         7.32\n4 3         6.98\n\nCounterfactual mean outcomes (post-intervention means):\n# A tibble: 4 × 2\n  X     estimate\n  &lt;fct&gt;    &lt;dbl&gt;\n1 1         7.60\n2 4         7.03\n3 2         7.36\n4 3         7.11\n\nFactual disparities:\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4    0.899\n 2 1 - 2    0.275\n 3 1 - 3    0.614\n 4 4 - 1   -0.899\n 5 4 - 2   -0.624\n 6 4 - 3   -0.286\n 7 2 - 1   -0.275\n 8 2 - 4    0.624\n 9 2 - 3    0.339\n10 3 - 1   -0.614\n11 3 - 4    0.286\n12 3 - 2   -0.339\n\nCounterfactual disparities (gap-closing estimands):\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4   0.566 \n 2 1 - 2   0.241 \n 3 1 - 3   0.483 \n 4 4 - 1  -0.566 \n 5 4 - 2  -0.325 \n 6 4 - 3  -0.0830\n 7 2 - 1  -0.241 \n 8 2 - 4   0.325 \n 9 2 - 3   0.242 \n10 3 - 1  -0.483 \n11 3 - 4   0.0830\n12 3 - 2  -0.242 \n\nAdditive gap closed: Counterfactual - Factual\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4   0.334 \n 2 1 - 2   0.0339\n 3 1 - 3   0.131 \n 4 4 - 1  -0.334 \n 5 4 - 2  -0.300 \n 6 4 - 3  -0.203 \n 7 2 - 1  -0.0339\n 8 2 - 4   0.300 \n 9 2 - 3   0.0972\n10 3 - 1  -0.131 \n11 3 - 4   0.203 \n12 3 - 2  -0.0972\n\nProportional gap closed: (Counterfactual - Factual) / Factual\n# A tibble: 12 × 2\n   X     estimate\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 1 - 4    0.371\n 2 1 - 2    0.123\n 3 1 - 3    0.214\n 4 4 - 1    0.371\n 5 4 - 2    0.480\n 6 4 - 3    0.710\n 7 2 - 1    0.123\n 8 2 - 4    0.480\n 9 2 - 3    0.287\n10 3 - 1    0.214\n11 3 - 4    0.710\n12 3 - 2    0.287\n\ndisparityplot(fit_gapclosing_ranger, category_A = \"1\", category_B = \"4\")\n\n\n\n\n\n\n\ndisparityplot(fit_gapclosing_ranger, category_A = \"1\", category_B = \"2\")\n\n\n\n\n\n\n\ndisparityplot(fit_gapclosing_ranger, category_A = \"1\", category_B = \"3\")"
  },
  {
    "objectID": "blog/posts/r_installation_with_rig.html",
    "href": "blog/posts/r_installation_with_rig.html",
    "title": "バージョンを指定したRのインストール",
    "section": "",
    "text": "わたし：Macユーザーで、MacのソフトウェアはすべてHomebrewで管理\nある日：Rのバージョンが4.4.0になっていたのに気づかずにアップデートしてしまった\nやりたいこと：Rのバージョンを4.3.3に戻したい"
  },
  {
    "objectID": "blog/posts/r_installation_with_rig.html#背景",
    "href": "blog/posts/r_installation_with_rig.html#背景",
    "title": "バージョンを指定したRのインストール",
    "section": "",
    "text": "わたし：Macユーザーで、MacのソフトウェアはすべてHomebrewで管理\nある日：Rのバージョンが4.4.0になっていたのに気づかずにアップデートしてしまった\nやりたいこと：Rのバージョンを4.3.3に戻したい"
  },
  {
    "objectID": "blog/posts/r_installation_with_rig.html#こんなのを見つけた",
    "href": "blog/posts/r_installation_with_rig.html#こんなのを見つけた",
    "title": "バージョンを指定したRのインストール",
    "section": "こんなのを見つけた",
    "text": "こんなのを見つけた\nイマドキRのインストール事情？ ～rig、pak、p3m～\nどうやらrigというものを使えば、Rのバージョンを指定してインストールできるらしい。"
  },
  {
    "objectID": "blog/posts/r_installation_with_rig.html#使ってみる",
    "href": "blog/posts/r_installation_with_rig.html#使ってみる",
    "title": "バージョンを指定したRのインストール",
    "section": "使ってみる",
    "text": "使ってみる\ngithubを見ながらインストール。\nまずはrigをhomebrewからインストール\nbrew tap r-lib/rig\nbrew install --cask rig \n次に、rigを使ってインストールしたいRのバージョンを指定してインストール\nrig add 4.3.3\nアンインストールしたい時はこう\nrig rm 4.3.3\nかんたん！"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "",
    "text": "Sudharsanan, Nikkil & Maarten J. Bijlsma, 2021, “Educational Note: Causal Decomposition of Population Health Differences Using Monte Carlo Integration and the G-Formula,” International Journal of Epidemiology, 50(6): 2098–2107 (10.1093/ije/dyab090)."
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#文献",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#文献",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "",
    "text": "Sudharsanan, Nikkil & Maarten J. Bijlsma, 2021, “Educational Note: Causal Decomposition of Population Health Differences Using Monte Carlo Integration and the G-Formula,” International Journal of Epidemiology, 50(6): 2098–2107 (10.1093/ije/dyab090)."
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#下準備",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#下準備",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "下準備",
    "text": "下準備\n\nパッケージ\n\n\nlibrary(tidyverse)\nlibrary(cfdecomp)\n\nkable &lt;- partial(\n  knitr::kable,\n  digits = 3\n)\n\n\nデータ\n\n\n# the decomposition functions in our package are computationally intensive\n# to make the example run quick, I perform it on a subsample (n=125) of the data:\nset.seed(100)\ndata &lt;- \n  cfd.example.data[sample(1000),] |&gt; \n  select(SES, age, med.gauss, out.gauss, id) |&gt; \n  as_tibble()"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#パッケージによる推定",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#パッケージによる推定",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "パッケージによる推定",
    "text": "パッケージによる推定\n\ncfdecompパッケージで推定\n\n\n# cfd.mean \nmean.results.1 &lt;- \n  cfd.mean(\n    formula.y = out.gauss ~ SES * med.gauss * age,\n    formula.m = med.gauss ~ SES * age,\n    mediator = 'med.gauss',\n    group = 'SES',\n    data = as.data.frame(data),\n    family.y = 'gaussian',\n    family.m = 'gaussian',\n    bs.size=250,\n    mc.size=10,\n    alpha=0.05,\n    # cluster.sample=FALSE,\n    # cluster.name='id'\n  )\n\n\nSES2とSES3のmediatorの分布をSES1のmediatorの分布に揃える\n\n\ntibble(\n  category = c(\"SES1\", \"SES2\", \"SES3\"),\n  factual_mean = c(\n    mean(mean.results.1$out_nc_y[, 1]),\n    mean(mean.results.1$out_nc_y[, 2]),\n    mean(mean.results.1$out_nc_y[, 3])\n  ),\n  # and after giving the gaussian mediator of SES group 2 the distribution of the one in group 1\n  # the difference becomes:\n  counterfactual_mean = c(\n    mean(mean.results.1$out_cf_y[, 1]),\n    mean(mean.results.1$out_cf_y[, 2]),\n    mean(mean.results.1$out_cf_y[, 3])\n  )) |&gt; \n  kable()\n\n\n\n\ncategory\nfactual_mean\ncounterfactual_mean\n\n\n\n\nSES1\n4.306\n4.306\n\n\nSES2\n3.239\n3.511\n\n\nSES3\n2.212\n2.946"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#自分でコードを書いてみる",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#自分でコードを書いてみる",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "自分でコードを書いてみる",
    "text": "自分でコードを書いてみる"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-1-regression-estimates",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-1-regression-estimates",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "step 1: regression estimates",
    "text": "step 1: regression estimates\n\nmediatorとoutcomeのモデルをデータから推定\n\n\nmediator_model &lt;- lm(med.gauss ~ SES * age, data = data)\noutcome_model &lt;- lm(out.gauss ~ SES * age * med.gauss, data = data)"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-2-simulate-the-natural-course-pseudo-population",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-2-simulate-the-natural-course-pseudo-population",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "step 2: simulate the natural-course pseudo-population",
    "text": "step 2: simulate the natural-course pseudo-population\n\n推定したmediatorのモデルから、mediatorの「分布」を再現\n\n\\[\\begin{align*}\nMed_i = \\mathrm{E}[Med | X] + e_i \\\\\ne_i \\sim \\mathrm{N}(0, \\sigma)\n\\end{align*}\\]\n\nmediatorの分布のパラメータを取得\n\n\n# predict mediator\n# mediatorの「分布」のパラメータを取得\npred_mean_m &lt;- predict(mediator_model, newdata = data, type = \"response\")\nresidual_ref_m &lt;- mediator_model$residuals\nsd_ref_m &lt;- sd(residual_ref_m)\n\n\n推定したパラメータをもとに、mediatorの値をシミュレート\n\n\ndf_nc_med &lt;- \n  data |&gt; \n  mutate(\n    # ランダム性なし\n    pred_med = pred_mean_m,\n    # ランダム性をもたせる1（推定した標準偏差のパラメータを使用）\n    pred_med_draw_1 = rnorm(n(), mean = pred_mean_m, sd = sd_ref_m),\n    # ランダム性をもたせる2（残差からランダムにサンプリング）\n    pred_med_draw_2 = pred_mean_m + sample(residual_ref_m, n(), replace = TRUE)\n  )\n\ndf_nc_med |&gt; \n  summarise(\n    across(c(med.gauss, pred_med:pred_med_draw_2), mean),\n    .by = SES\n  ) |&gt; \n  arrange(SES) |&gt; \n  kable()\n\n\n\n\nSES\nmed.gauss\npred_med\npred_med_draw_1\npred_med_draw_2\n\n\n\n\n1\n8.428\n8.428\n8.418\n8.286\n\n\n2\n7.223\n7.223\n7.276\n7.454\n\n\n3\n5.410\n5.410\n5.579\n5.374\n\n\n\n\n\n\nシミュレートした値をoutcomeモデルに代入して予測値を計算・集計\n\n\ndf_nc_med |&gt; \n  mutate(\n    # ランダム性なし\n    pred_out = predict(\n      outcome_model, newdata = df_nc_med |&gt; mutate(med.gauss = pred_med)\n    ),\n    # ランダム性をもたせる1（推定した標準偏差のパラメータを使用）\n    pred_out_draw_1 = predict(\n      outcome_model, newdata = df_nc_med |&gt; mutate(med.gauss = pred_med_draw_1)\n    ),\n    # ランダム性をもたせる2（残差からランダムにサンプリング）\n    pred_out_draw_2 = predict(\n      outcome_model, newdata = df_nc_med |&gt; mutate(med.gauss = pred_med_draw_2)\n    )\n  ) |&gt; \n  summarise(\n    across(c(out.gauss, pred_out:pred_out_draw_2), mean),\n    .by = SES\n  ) |&gt; \n  arrange(SES) |&gt; \n  kable()\n\n\n\n\nSES\nout.gauss\npred_out\npred_out_draw_1\npred_out_draw_2\n\n\n\n\n1\n4.309\n4.309\n4.312\n4.286\n\n\n2\n3.237\n3.237\n3.249\n3.292\n\n\n3\n2.217\n2.217\n2.254\n2.214"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-3-simulate-the-counterfactual-pseudo-population",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#step-3-simulate-the-counterfactual-pseudo-population",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "step 3: simulate the counterfactual pseudo-population",
    "text": "step 3: simulate the counterfactual pseudo-population\n\n推定したmediatorのモデルにおいて、全員のSESが1だった場合のmediatorの分布を再現\n全員のSESを1にしてmediatorのパラメータを取得\n回帰モデルでは残差の部分は共変量に依存しない（SES間で分布が同じ、平均0・共通の標準偏差の正規分布）\n\nならばSESが1のグループの標準偏差を使わなくても良いのでは？（全体の標準偏差でもよい）\n標準偏差もグループによって異なる、といったモデルの場合にはどうなるか？\n\n\n\n# 平均\npred_mean_m_SES1 &lt;- predict(mediator_model, newdata = data |&gt; mutate(SES = '1'))\n# SES = 1のグループの残差\nresidual_ref_m_SES1 &lt;-\n  broom::augment(mediator_model)  |&gt;\n  filter(SES == '1') |&gt; \n  pull(.resid)\n# 標準偏差\nsd_ref_m_SES1 &lt;- sd(residual_ref_m_SES1)\n\n\n推定したパラメータをもとに、mediatorの値をシミュレート\n\n\ndf_cf_med &lt;- \n  data |&gt; \n  mutate(\n    # ランダム性なし\n    pred_med_SES1 = pred_mean_m_SES1,\n    # ランダム性をもたせる1（推定した標準偏差のパラメータを使用）\n    pred_med_draw_1_SES1 = rnorm(n(), mean = pred_mean_m_SES1, sd = sd_ref_m_SES1),\n    # ランダム性をもたせる2（残差からランダムにサンプリング）\n    pred_med_draw_2_SES1 = pred_mean_m_SES1 + sample(residual_ref_m_SES1, n(), replace = TRUE)\n  )\n\ndf_cf_med |&gt; \n  summarise(\n    across(c(med.gauss, pred_med_SES1:pred_med_draw_2_SES1), mean),\n    .by = SES\n  ) |&gt; \n  arrange(SES) |&gt; \n  kable()\n\n\n\n\n\n\n\n\n\n\n\nSES\nmed.gauss\npred_med_SES1\npred_med_draw_1_SES1\npred_med_draw_2_SES1\n\n\n\n\n1\n8.428\n8.428\n8.386\n8.632\n\n\n2\n7.223\n8.337\n8.258\n8.292\n\n\n3\n5.410\n8.442\n8.292\n8.593\n\n\n\n\n\n\nシミュレートした値をoutcomeモデルに代入して予測値を計算・集計\n\n\ndf_cf_med |&gt; \n  mutate(\n    # ランダム性なし\n    pred_out_SES1 = predict(\n      outcome_model, newdata = df_cf_med |&gt; mutate(med.gauss = pred_med_SES1)\n    ),\n    # ランダム性をもたせる1（推定した標準偏差のパラメータを使用）\n    pred_out_draw_1_SES1 = predict(\n      outcome_model, newdata = df_cf_med |&gt; mutate(med.gauss = pred_med_draw_1_SES1)\n    ),\n    # ランダム性をもたせる2（残差からランダムにサンプリング）\n    pred_out_draw_2_SES1 = predict(\n      outcome_model, newdata = df_cf_med |&gt; mutate(med.gauss = pred_med_draw_2_SES1)\n    )\n  ) |&gt; \n  summarise(\n    across(c(out.gauss, pred_out_SES1:pred_out_draw_2_SES1), mean),\n    .by = SES\n  ) |&gt; \n  arrange(SES) |&gt; \n  kable()\n\n\n\n\n\n\n\n\n\n\n\nSES\nout.gauss\npred_out_SES1\npred_out_draw_1_SES1\npred_out_draw_2_SES1\n\n\n\n\n1\n4.309\n4.309\n4.303\n4.347\n\n\n2\n3.237\n3.507\n3.485\n3.498\n\n\n3\n2.217\n2.949\n2.920\n2.979"
  },
  {
    "objectID": "blog/posts/Sudharsanan_Bijlsma_2021.html#monte-carloとbootstrapの実装",
    "href": "blog/posts/Sudharsanan_Bijlsma_2021.html#monte-carloとbootstrapの実装",
    "title": "Sudharsanan & Bijlsma (2021)",
    "section": "monte carloとbootstrapの実装",
    "text": "monte carloとbootstrapの実装\n\n実際にはrandom drawは一回ではなく何回か行うことで不確実性を表現する\n標準誤差の推定のためにbootstrap法も必要\nまずはtreatmentとoutcomeのモデルを推定し、パラメータを取得\n\n\n# パラメータ推定\nestimate_model &lt;- function(data) {\n  \n  mediator_model &lt;- lm(med.gauss ~ SES * age, data = data)\n  outcome_model &lt;- lm(out.gauss ~ SES * age * med.gauss, data = data)\n  \n  pred_mean_m &lt;- predict(mediator_model, newdata = data, type = \"response\")\n  residual_ref_m &lt;- mediator_model$residuals\n  sd_ref_m &lt;- sd(residual_ref_m)\n\n  pred_mean_m_SES1 &lt;- predict(mediator_model, newdata = data |&gt; mutate(SES = '1'))\n  residual_ref_m_SES1 &lt;-\n    broom::augment(mediator_model)  |&gt;\n    filter(SES == '1') |&gt; \n    pull(.resid)\n  sd_ref_m_SES1 &lt;- sd(residual_ref_m_SES1)\n\n}\n\n\nパラメータをもとにmediatorをシミュレートするのを何回か繰り返す\n\n\nmontecarlo_sampling &lt;- function(data, mc = 10) {\n  # パラメータ推定\n  estimate_model(data)\n  # モンテカルロシミュレーション\n  map(1:mc, \\(mc) {\n    # mediatorサンプリング\n    boot_sample &lt;- \n      data |&gt; \n      mutate(\n        pred_med_draw_1 = rnorm(n(), mean = pred_mean_m, sd = sd_ref_m),\n        pred_med_draw_2 = pred_mean_m + sample(residual_ref_m, n(), replace = TRUE),\n        pred_med_draw_1_SES1 = rnorm(n(), mean = pred_mean_m_SES1, sd = sd_ref_m_SES1),\n        pred_med_draw_2_SES1 = pred_mean_m_SES1 + sample(residual_ref_m_SES1, n(), replace = TRUE),\n      )\n    # サンプリングしたものからoutcome予測\n    boot_sample |&gt; \n      mutate(\n        pred_out_draw_1 = predict(\n          outcome_model, newdata = boot_sample |&gt; mutate(med.gauss = pred_med_draw_1)\n        ),\n        pred_out_draw_2 = predict(\n          outcome_model, newdata = boot_sample |&gt; mutate(med.gauss = pred_med_draw_2)\n        ),\n        pred_out_draw_1_SES1 = predict(\n          outcome_model, newdata = boot_sample |&gt; mutate(med.gauss = pred_med_draw_1_SES1)\n        ),\n        pred_out_draw_2_SES1 = predict(\n          outcome_model, newdata = boot_sample |&gt; mutate(med.gauss = pred_med_draw_2_SES1)\n        )\n      ) |&gt; \n      group_by(SES) |&gt; \n      summarise(across(c(pred_out_draw_1:pred_out_draw_2_SES1), mean))\n    \n  }) |&gt; \n    list_rbind(names_to = 'mc') |&gt; \n    # シミュレーション結果を集計\n    group_by(SES) |&gt; \n    summarise(across(c(pred_out_draw_1:pred_out_draw_2_SES1), mean))\n  \n}\n\n\nこれをbootstrapで繰り返す\n\n\nresult &lt;- \n  map(1:250, \\(index) {\n    # bootstrapサンプル発生\n    bootsample &lt;- slice_sample(data, prop = 1, replace = TRUE)\n    montecarlo_sampling(bootsample, mc = 10) \n  }) |&gt; \n  list_rbind(names_to = 'index')\n\n\n結果を集計\n\n\nresult |&gt; \n  pivot_longer(\n    cols = c(pred_out_draw_1:pred_out_draw_2_SES1), \n    names_to = 'type', \n    values_to = 'value'\n  ) |&gt; \n  summarise(\n    mean = mean(value), \n    conf.low = quantile(value, 0.025),\n    conf.high = quantile(value, 0.975),\n    .by = c(SES, type)\n  ) |&gt; \n  arrange(type) |&gt; \n  kable()\n\n\n\n\nSES\ntype\nmean\nconf.low\nconf.high\n\n\n\n\n1\npred_out_draw_1\n4.015\n3.937\n4.091\n\n\n2\npred_out_draw_1\n3.183\n3.124\n3.251\n\n\n3\npred_out_draw_1\n2.645\n2.599\n2.688\n\n\n1\npred_out_draw_1_SES1\n4.276\n4.193\n4.351\n\n\n2\npred_out_draw_1_SES1\n3.513\n3.446\n3.582\n\n\n3\npred_out_draw_1_SES1\n2.970\n2.934\n3.000\n\n\n1\npred_out_draw_2\n4.015\n3.938\n4.094\n\n\n2\npred_out_draw_2\n3.182\n3.123\n3.253\n\n\n3\npred_out_draw_2\n2.646\n2.600\n2.687\n\n\n1\npred_out_draw_2_SES1\n4.276\n4.183\n4.358\n\n\n2\npred_out_draw_2_SES1\n3.515\n3.457\n3.584\n\n\n3\npred_out_draw_2_SES1\n2.970\n2.941\n2.998"
  },
  {
    "objectID": "blog/posts/how_to_change_BLAS.html",
    "href": "blog/posts/how_to_change_BLAS.html",
    "title": "BLASの変更によるRの高速化",
    "section": "",
    "text": "Do GPU-based Basic Linear Algebra Subprograms (BLAS) improve the performance of standard modeling techniques in R?\nEven faster matrix math in R on macOS with M1\nNVBLASを使って「R」の並列演算処理を高速化"
  },
  {
    "objectID": "blog/posts/how_to_change_BLAS.html#参考",
    "href": "blog/posts/how_to_change_BLAS.html#参考",
    "title": "BLASの変更によるRの高速化",
    "section": "",
    "text": "Do GPU-based Basic Linear Algebra Subprograms (BLAS) improve the performance of standard modeling techniques in R?\nEven faster matrix math in R on macOS with M1\nNVBLASを使って「R」の並列演算処理を高速化"
  },
  {
    "objectID": "blog/posts/how_to_change_BLAS.html#概要",
    "href": "blog/posts/how_to_change_BLAS.html#概要",
    "title": "BLASの変更によるRの高速化",
    "section": "概要",
    "text": "概要\nR言語の計算速度はそれほど速くはないが、いくつか工夫することで高速化が可能。\n\nベクトル演算の駆使\n並列化（paralell, future, furrrなど）\nBLAS (Basic Linear Algebra Subprograms) の変更\n\n今回はBLASの変更による高速化について。"
  },
  {
    "objectID": "blog/posts/how_to_change_BLAS.html#blasとは",
    "href": "blog/posts/how_to_change_BLAS.html#blasとは",
    "title": "BLASの変更によるRの高速化",
    "section": "BLASとは",
    "text": "BLASとは\nBLASは、行列演算を高速に行うためのライブラリ。たとえば分散や共分散を計算するときは、行列の掛け算をする必要がある。機械学習やニューラルネットワークでは行列の掛け算が多用されるため、BLASの高速化は全体としての計算速度の向上に大きく貢献する。\nBLASはオープンソースのものもあるが、各CPU、GPUメーカーがそれぞれのチップに適したライブラリを提供している。\n\nRについてるBLAS\n\nRにデフォルトでついてくるBLAS\n\nOpenBLAS\n\nオープンソースのBLASで、homebrewでインストール可能\npythonのnumpyで使われているらしい\n\nATLAS\n\nこちらもオープンソース\n\nMKL\n\nIntelが提供するBLAS\nMacだと使えない\n\nNVBLAS\n\nNVIDIAが提供するBLAS\nGPUを使用するのでめちゃくちゃ速いらしい\nNVIDIAのGPUじゃないと使えない…\n\nAccelerate\n\nAppleが提供\n今回使用するやつ"
  },
  {
    "objectID": "blog/posts/how_to_change_BLAS.html#blasの変更",
    "href": "blog/posts/how_to_change_BLAS.html#blasの変更",
    "title": "BLASの変更によるRの高速化",
    "section": "BLASの変更",
    "text": "BLASの変更\n以下、homebrewでRをインストールしていることを前提とする。\nterminalで以下のコマンドを実行する。\ncd /Library/Frameworks/R.framework/Resources/lib\nln -sf libRblas.veclib.dylib libRblas.dylib\n意味としては、RはlibRblas.dylibをBLASとして認識するので、libRblas.veclib.dylibをlibRblas.dylibにリンクすることで、libRblas.veclib.dylibをBLASとして使うようにする。\nもどすときはlibRblas.veclib.dylibの代わりに、libRblas.0.dylib（デフォルトのBLAS）をリンクすればよい。\ncd /Library/Frameworks/R.framework/Resources/lib\nln -sf libRblas.0.dylib libRblas.dylib"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html",
    "href": "blog/posts/Borusyak_2024.html",
    "title": "Borusyak et al. (2024)",
    "section": "",
    "text": "Borusyak, Kirill, Xavier Jaravel & Jann Spiess, 2024, “Revisiting Event-Study Designs: Robust and Efficient Estimation,” The Review of Economic Studies, (10.1093/restud/rdae007)."
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#文献",
    "href": "blog/posts/Borusyak_2024.html#文献",
    "title": "Borusyak et al. (2024)",
    "section": "",
    "text": "Borusyak, Kirill, Xavier Jaravel & Jann Spiess, 2024, “Revisiting Event-Study Designs: Robust and Efficient Estimation,” The Review of Economic Studies, (10.1093/restud/rdae007)."
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#ざっくりとした要約",
    "href": "blog/posts/Borusyak_2024.html#ざっくりとした要約",
    "title": "Borusyak et al. (2024)",
    "section": "ざっくりとした要約",
    "text": "ざっくりとした要約\nDiD推定をg-computationのようなアイデアで行う手法を提案した論文です。従来のTwo-way fixed effectによる推定では問題が生じることが指摘されてきた、処置のタイミングによる効果の異質性（staggerd DiD design）の問題などに対処しています。通常g-computationによる推定量の標準誤差はBootstrapで計算することが多いと思うのですが、この論文では推定量の漸近正規性などを示しつつ、Bootstrapを使わずに標準誤差を計算する方法を提案している点が興味深いです。"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#estimand",
    "href": "blog/posts/Borusyak_2024.html#estimand",
    "title": "Borusyak et al. (2024)",
    "section": "Estimand",
    "text": "Estimand\n\n\\(Y_{it}(1), Y_{it}(0)\\)：個人\\(i\\)、時点\\(t\\)における介入を受けた場合と受けていない場合のpotential outcome\n\\(D_{it}\\)：介入を受けたかどうかのバイナリ変数\n\n個人レベルの因果効果\n\\[\\begin{align*}\n\\tau_{it} = Y_{it}(1) - Y_{it}(0) = Y_{it} - Y_{it}(0)\n\\end{align*}\\]\nこれを関心のある集団について平均する\n\nATT：\\(\\mathrm{E}[\\tau_{it}|D_{it} = 1] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1]\\)\nevent study：\\(\\mathrm{E}[\\tau_{it}|D_{it} = 1, T = t] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1, T = t]\\)\n特定の集団におけるATT：\\(\\mathrm{E}[\\tau_{it}|D_{it} = 1, Gender] = \\mathrm{E}[Y_{it} - Y_{it}(0) | D_{it} = 1, Gender]\\)\n\n論文ではウェイトを使った書き方をしているのでややこしいが、おそらくはこういうことだと思われる。"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#識別",
    "href": "blog/posts/Borusyak_2024.html#識別",
    "title": "Borusyak et al. (2024)",
    "section": "識別",
    "text": "識別\n因果効果を識別するための仮定は以下の通り\n\nGeneral moodel of \\(Y(0)\\)：\\(\\mathrm{E}[Y_{it}(0)] = A'_{it}\\lambda_i + X'_{it}\\delta\\)の形で書けること\n\n\n\\(A'_{it}\\lambda_i\\)：個体の固定効果＋固定効果と共変量の交互作用\n\\(X'_{it}\\delta\\)：時点の固定効果＋時変の共変量\n要するに\\(\\mathrm{E}[Y_{it}(0)]\\)が適切のモデル化できていること\n\n\nNo-anticipation effects：\\(Y_{it} = Y_{it}(0) \\ if \\ D_{it} = 0\\)\n\n\nConsistencyと同じ？\n\n\nModel of causal effects\n\n\n効果の異質性がパラメトリックモデルで書けること（？）\n複雑すぎるとダメということ？このあたりちょっとわからなかったです"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#推定",
    "href": "blog/posts/Borusyak_2024.html#推定",
    "title": "Borusyak et al. (2024)",
    "section": "推定",
    "text": "推定\n\n\\(\\mathrm{E}[Y_{it}(0)]\\)の推定\n\n\n処置を受けていないサンプル（\\(D_{it} = 0\\)）を用いて、以下のモデルをOLSで推定\n\n\\[\nY_{it} = A'_{it}\\lambda_i + X'_{it}\\delta + \\varepsilon_{it}\n\\]\n\n\\(\\hat{Y}_{it}(0) | D_{it} = 1\\) の推定\n\n\n推定したモデルに、処置を受けたサンプル（\\(D_{it} = 1\\)）を代入し、処置を受けたサンプルにおいて、処置を受けていなかった場合のpotential outcomeを予測\n\n\n\\(\\hat{\\tau}_{it}\\)の推定\n\n\n処置を受けたサンプルの、観察データ\\(Y_{it}\\)と予測したpotential outcome\\(\\hat{Y}_{it}(0)\\)の差を取る\n\n\n関心のある集団について平均値をとる\n\n\\[\n\\mathrm{ATT} = \\mathrm{E}[\\hat{\\tau}_{it}|D_{it} = 1]\n\\]\n標準誤差の推定も説明があるが、理解できなかった…"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#分析例",
    "href": "blog/posts/Borusyak_2024.html#分析例",
    "title": "Borusyak et al. (2024)",
    "section": "分析例",
    "text": "分析例\n著者によるStataパッケージの他、RではKyle Buttsによるdidimputationパッケージがある。\nここではdidimputationパッケージのトイデータを用いて、パッケージによる結果と、手計算による結果を比較する。\n\n# remotes::install_github('kylebutts/didimputation')\nlibrary(tidyverse)\nlibrary(fixest)\nlibrary(didimputation)"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#パッケージの結果",
    "href": "blog/posts/Borusyak_2024.html#パッケージの結果",
    "title": "Borusyak et al. (2024)",
    "section": "パッケージの結果",
    "text": "パッケージの結果\n\ndid_imputation(data = df_het, yname = \"dep_var\", gname = \"g\", tname = \"year\", idname = \"unit\") |&gt; \n  knitr::kable()\n\n\n\n\nterm\nestimate\nstd.error\nconf.low\nconf.high\n\n\n\n\ntreat\n2.262952\n0.0313968\n2.201414\n2.32449"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#手計算",
    "href": "blog/posts/Borusyak_2024.html#手計算",
    "title": "Borusyak et al. (2024)",
    "section": "手計算",
    "text": "手計算\n\n# OLSで処置を受けていないサンプルにおけるモデルを推定\nmodel &lt;- feols(dep_var ~ 1 | year + unit, data = df_het |&gt; filter(!treat), combine.quick = TRUE)\n\nprediction &lt;- \n  # 処置を受けた集団の予測値（potential outcome）を計算\n  broom::augment(model, newdata = df_het |&gt; filter(treat)) |&gt; \n  # 差分を計算\n  mutate(tau = dep_var - .fitted) \n\n# 集計\nprediction |&gt; \n  summarise(\n    ATT = mean(tau)\n  ) |&gt; \n  knitr::kable()\n\n\n\n\nATT\n\n\n\n\n2.262952\n\n\n\n\n\nATTの点推定値は一致する。"
  },
  {
    "objectID": "blog/posts/Borusyak_2024.html#集団による異質性",
    "href": "blog/posts/Borusyak_2024.html#集団による異質性",
    "title": "Borusyak et al. (2024)",
    "section": "集団による異質性",
    "text": "集団による異質性\n次に、処置のタイミングにより効果が異なる場合の分析を考える。\nパッケージでは以下のように、処置のタイミングが同じグループごとにウェイトを作成してやることで、集団ごとの効果を推定できる。\n\ndf_het |&gt; \n  mutate(\n    group1 = case_when(\n      group == 'Group 1' & treat ~ 1,\n      .default = 0\n    ),\n    group2 = case_when(\n      group == 'Group 2' & treat ~ 1,\n      .default = 0\n    )\n  ) |&gt; \n  did_imputation(yname = \"dep_var\", gname = \"g\", tname = \"year\", idname = \"unit\", wtr = c('group1', 'group2')) |&gt; \n  knitr::kable()\n\n\n\n\nterm\nestimate\nstd.error\nconf.low\nconf.high\n\n\n\n\ngroup1\n2.513439\n0.0381686\n2.438629\n2.588249\n\n\ngroup2\n1.795048\n0.0389609\n1.718685\n1.871412\n\n\n\n\n\n手計算では、集計をグループごとに行えばよい。\n\n# 集計\nprediction |&gt; \n  summarise(\n    ATT = mean(tau),\n    .by = c(group)\n  ) |&gt; \n  knitr::kable()\n\n\n\n\ngroup\nATT\n\n\n\n\nGroup 1\n2.513439\n\n\nGroup 2\n1.795048\n\n\n\n\n\nこちらも点推定値は一致する。"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html",
    "href": "blog/posts/tensorflow_with_Rstudio.html",
    "title": "tensorflowをRstudioで",
    "section": "",
    "text": "pythonをRStudioで使うのはreticulateパッケージによりだいぶ楽になった。\nただpythonにおけるdeep learningの代表的パッケージであるtensorflowをRStudioで使う際に少しつまづいたのでメモです。"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html#pythonの環境をどうやって構築するか",
    "href": "blog/posts/tensorflow_with_Rstudio.html#pythonの環境をどうやって構築するか",
    "title": "tensorflowをRstudioで",
    "section": "pythonの環境をどうやって構築するか？",
    "text": "pythonの環境をどうやって構築するか？\nRではrenvパッケージを使っている。ではpythonでは？\npythonはRよりも環境が複雑で変化も早そうなので、環境構築は重要。\n今回はpython公式が推奨しているっぽいvenvを使う。\n\n\n\n\n\n\nNote\n\n\n\n最初global環境でそのままやろうとしたが上手くいかず挫折。Dockerとかも有力だと思う。"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html#venvを使って仮想環境を用意",
    "href": "blog/posts/tensorflow_with_Rstudio.html#venvを使って仮想環境を用意",
    "title": "tensorflowをRstudioで",
    "section": "venvを使って仮想環境を用意",
    "text": "venvを使って仮想環境を用意\n\npythonがインストールされているか確認\n\nhomebrewなりでインストールしておく\nPATHを通しておく\n\n作業ディレクトリにて、terminalで以下のコマンドを実行し.venvフォルダを作成\n\n\n\n\nterminal\n\npython3 -m venv .venv"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html#pythonライブラリをインストール",
    "href": "blog/posts/tensorflow_with_Rstudio.html#pythonライブラリをインストール",
    "title": "tensorflowをRstudioで",
    "section": "pythonライブラリをインストール",
    "text": "pythonライブラリをインストール\n\n以下のコマンドを実行し、仮想環境を起動\n\npythonの場所が.venv内のフォルダになる\n\n\n\n\n\nterminal\n\nsource .venv/bin/activate\n\n\n\n\n\n\n\n\nNote\n\n\n\nsource .venv/bin/activateは、ライブラリをインストールするときは毎回実行する必要があります！\nまちがってglobal環境を汚さないように！\n\n\n\nライブラリをインストール\n\ntensorflowのほか、numpyも必須（tensorflowをインストールしたときに入る）\nM1 macでGPUを使いたい場合はtensorflow-metalもインストールする\n\n\n\n\n\nterminal\n\npip install tensorflow-macos\npip install tensorflow-metal\n\n\n\n仮想環境を抜けるときは以下のコマンドを実行\n\n\n\n\nterminal\n\ndeactivate"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html#rstudioでpythonを使う",
    "href": "blog/posts/tensorflow_with_Rstudio.html#rstudioでpythonを使う",
    "title": "tensorflowをRstudioで",
    "section": "RStudioでpythonを使う",
    "text": "RStudioでpythonを使う\n\npythonの場所を指定\n\nRStudioでpythonを使うには、RStudioにpythonの場所を教えてやる必要がある\n\n今回は.venv内のpythonを使いたいので、作業ディレクトリに.Rprofileを作成し、以下のコードを書く\nrenvを使っている場合は、.Rprofileが既に作成されていると思うので、その中に追記する\n\n\n\n\n\n.Rprofile\n\n# renv起動\nsource(\"renv/activate.R\")\n# pythonの場所を指定\nSys.setenv(RETICULATE_PYTHON = \".venv/bin/python3\")\n\n\n\n\n\n\n\n\nNote\n\n\n\npythonの場所の指定はrenvの起動より後に行う必要がある。もし先にpythonの場所を指定してしまうと、renvを起動したときにpythonの場所が上書きされてしまい、上手くいかなくなる。\n\n\n\n\npythonを起動\n\nRStudioでpythonのコードを実行すると、reticulate::repl_python()が走ってコンソールがpythonになる\n\n\n\n\npython\n\nimport sys\nprint(sys.version)\n\n\n3.11.10 (main, Sep  7 2024, 01:03:31) [Clang 15.0.0 (clang-1500.3.9.4)]\n\n\n\ntensorflowを起動して、GPUが使えるかを確認\nphysical_deviceでCPUとGPUの両方が表示されてればOK\n\n\n\n\npython\n\nimport tensorflow as tf\ntf.config.list_physical_devices()\n\n\n[PhysicalDevice(name='/physical_device:CPU:0', device_type='CPU'), PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')]"
  },
  {
    "objectID": "blog/posts/tensorflow_with_Rstudio.html#ニューラルネットをやってみる",
    "href": "blog/posts/tensorflow_with_Rstudio.html#ニューラルネットをやってみる",
    "title": "tensorflowをRstudioで",
    "section": "ニューラルネットをやってみる",
    "text": "ニューラルネットをやってみる\n\nチュートリアルとして、手書きのアルファベットを分類するモデルを作成してみる\nRでデータを読み込んで、pythonに渡してtensorflowで分析\n参考\n\n\n\n\nR\n\nlibrary(tidyverse)\nlibrary(rsample)\nlibrary(reticulate)\n\n\n\nデータのダウンロード\n\n\n\nR\n\n# データのダウンロード\nif (!dir.exists('data')) dir.create('data')\ndownload.file('https://ai.stanford.edu/~btaskar/ocr/letter.data.gz', destfile = 'data/letter.data')\n\n\n\n\nデータの読み込み\n\n列名はhttps://ai.stanford.edu/~btaskar/ocr/letter.namesより取得できる\n詳細は以下の通り\n\nid: each letter is assigned a unique integer id\nletter: a-z\nnext_id: id for next letter in the word, -1 if last letter\nword_id: each word is assigned a unique integer id (not used)\nposition: position of letter in the word (not used)\nfold: 0-9 – cross-validation fold\np_i_j: 0/1 – value of pixel in row i, column j\n\nletterとp_i_j（pixel）のみ使うのでそれ以外は削除\n\n\n\n\nR\n\ncolname &lt;- read_lines('https://ai.stanford.edu/~btaskar/ocr/letter.names')\ndata &lt;- \n  read_tsv('data/letter.data', col_names = colname) |&gt; \n  # letterとpixelだけ残す\n  select(id, letter, matches('p_\\\\d+_\\\\d+'))\n\n\n\n\nデータの前処理\n\nletterを数値に変換\n\n\n\n\nR\n\ndf &lt;- \n  data |&gt; \n  mutate(\n    letter = factor(letter),\n    # pythonは0からはじまるので-1する（Rは1から）\n    letter_num = as.numeric(letter) - 1\n  )\n\n\n\n訓練データとテストデータに分割\n\n\n\n\nR\n\nsplit &lt;- rsample::initial_split(df, prop = 0.9)\ntrain &lt;- rsample::training(split)\ntest &lt;- rsample::testing(split)\n\n\n\npythonに渡せる形にデータを変換\n\nreticulate::np_array()であらかじめndarrayにしておくと便利\n\n\n\n\n\nR\n\ntrain_x &lt;- \n  train |&gt; \n  select(!c(id, letter, letter_num)) |&gt;\n  as.matrix() |&gt; \n  np_array()\n\ntrain_y &lt;-\n  train |&gt;\n  pull(letter_num) |&gt;\n  np_array()\n\ntest_x &lt;-\n  test |&gt; \n  select(!c(id, letter, letter_num)) |&gt;\n  as.matrix() |&gt; \n  np_array()\n\ntest_y &lt;-\n  test |&gt;\n  pull(letter_num) |&gt;\n  np_array()\n\n\n\n\nニューラルネットで学習\n\n中間層が1つのニューラルネットを作成\n\n入力層は16x8=128（ピクセル）\n中間層は64次元\n出力層はa-zの26分類\n\n\n\n\n\npython\n\nimport tensorflow as tf\nimport numpy as np\n\n# モデルの作成\nmodel = tf.keras.Sequential([\n  tf.keras.layers.Dense(64, activation='relu'),\n  tf.keras.layers.Dense(26, activation='softmax')\n])\n\nmodel.compile(\n  optimizer='adam',\n  loss='sparse_categorical_crossentropy',\n  metrics=['accuracy']\n)\n\n\n\nrで作成したデータをpythonに渡して学習\nr.train_xでRのtrain_xを参照できる\npythonのオブジェクトを渡すときはpy$train_x\n\n\n\n\npython\n\n# モデルの学習\nmodel.fit(r.train_x, r.train_y, epochs=10, verbose=2)\n\n\nEpoch 1/10\n1467/1467 - 5s - loss: 1.3436 - accuracy: 0.6342 - 5s/epoch - 4ms/step\nEpoch 2/10\n1467/1467 - 5s - loss: 0.9296 - accuracy: 0.7519 - 5s/epoch - 3ms/step\nEpoch 3/10\n1467/1467 - 5s - loss: 0.8666 - accuracy: 0.7679 - 5s/epoch - 3ms/step\nEpoch 4/10\n1467/1467 - 5s - loss: 0.8371 - accuracy: 0.7766 - 5s/epoch - 3ms/step\nEpoch 5/10\n1467/1467 - 5s - loss: 0.8229 - accuracy: 0.7802 - 5s/epoch - 3ms/step\nEpoch 6/10\n1467/1467 - 5s - loss: 0.8151 - accuracy: 0.7819 - 5s/epoch - 3ms/step\nEpoch 7/10\n1467/1467 - 5s - loss: 0.8121 - accuracy: 0.7816 - 5s/epoch - 3ms/step\nEpoch 8/10\n1467/1467 - 5s - loss: 0.8105 - accuracy: 0.7812 - 5s/epoch - 3ms/step\nEpoch 9/10\n1467/1467 - 5s - loss: 0.8127 - accuracy: 0.7813 - 5s/epoch - 3ms/step\nEpoch 10/10\n1467/1467 - 5s - loss: 0.8137 - accuracy: 0.7803 - 5s/epoch - 3ms/step\n&lt;keras.src.callbacks.History object at 0x30efc0f90&gt;\n\n\n\n\nテストデータで評価\n\nテストデータでの正答率は77%くらい\n\n\n\n\npython\n\n# モデルの評価\nmodel.evaluate(r.test_x, r.test_y, verbose=2)\n\n\n163/163 - 0s - loss: 0.8884 - accuracy: 0.7651 - 475ms/epoch - 3ms/step\n[0.8884354829788208, 0.7651457190513611]"
  },
  {
    "objectID": "blog/posts/信頼区間を理解したい.html",
    "href": "blog/posts/信頼区間を理解したい.html",
    "title": "信頼区間を理解したい",
    "section": "",
    "text": "信頼区間の意味がわかりやすいシミュレーション"
  },
  {
    "objectID": "blog/posts/信頼区間を理解したい.html#パッケージの読み込み",
    "href": "blog/posts/信頼区間を理解したい.html#パッケージの読み込み",
    "title": "信頼区間を理解したい",
    "section": "パッケージの読み込み",
    "text": "パッケージの読み込み\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "blog/posts/信頼区間を理解したい.html#設定",
    "href": "blog/posts/信頼区間を理解したい.html#設定",
    "title": "信頼区間を理解したい",
    "section": "設定",
    "text": "設定\n\n100人の研究者がいる\n各研究者がそれぞれデータをとる。N=500の調査を行う\nデータは平均0.5、標準偏差0.1の正規分布に従うと仮定\n\n\nset.seed(1)\n\ndata &lt;- \n  tibble(\n    # 100人の研究者がいる\n    researcher_ID = 1:100,\n    # 各研究者がそれぞれデータをとる。N=500の調査を行う。\n    data = map(researcher_ID, \\(researcher_ID) rnorm(500, 0.5, 0.1))\n  )\n\ndata\n\n# A tibble: 100 × 2\n   researcher_ID data       \n           &lt;int&gt; &lt;list&gt;     \n 1             1 &lt;dbl [500]&gt;\n 2             2 &lt;dbl [500]&gt;\n 3             3 &lt;dbl [500]&gt;\n 4             4 &lt;dbl [500]&gt;\n 5             5 &lt;dbl [500]&gt;\n 6             6 &lt;dbl [500]&gt;\n 7             7 &lt;dbl [500]&gt;\n 8             8 &lt;dbl [500]&gt;\n 9             9 &lt;dbl [500]&gt;\n10            10 &lt;dbl [500]&gt;\n# ℹ 90 more rows"
  },
  {
    "objectID": "blog/posts/信頼区間を理解したい.html#データから信頼区間を計算",
    "href": "blog/posts/信頼区間を理解したい.html#データから信頼区間を計算",
    "title": "信頼区間を理解したい",
    "section": "データから信頼区間を計算",
    "text": "データから信頼区間を計算\n\n各研究者のデータの平均値、標準誤差、信頼区間を計算\n信頼区間が真値（0.5）を含むかどうかを判定\n\n\ndata2 &lt;- \n  data |&gt; \n  # 各研究者のデータの平均値、標準誤差、信頼区間を計算\n  mutate(\n    mean = map_dbl(data, \\(data) mean(data)),\n    se = map_dbl(data, \\(data) sd(data) / sqrt(length(data))),\n    lower = mean - 1.96 * se,\n    upper = mean + 1.96 * se\n  ) |&gt;  \n  # 信頼区間が0.5を含むかどうかを判定\n  mutate(\n    flg = case_when(\n      0.5 &lt; lower | upper &lt; 0.5  ~ 'Error',\n      .default = 'Not Error'\n    )\n  )\n\ndata2\n\n# A tibble: 100 × 7\n   researcher_ID data         mean      se lower upper flg      \n           &lt;int&gt; &lt;list&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    \n 1             1 &lt;dbl [500]&gt; 0.502 0.00453 0.493 0.511 Not Error\n 2             2 &lt;dbl [500]&gt; 0.495 0.00473 0.486 0.505 Not Error\n 3             3 &lt;dbl [500]&gt; 0.500 0.00452 0.491 0.509 Not Error\n 4             4 &lt;dbl [500]&gt; 0.497 0.00479 0.488 0.506 Not Error\n 5             5 &lt;dbl [500]&gt; 0.501 0.00464 0.492 0.510 Not Error\n 6             6 &lt;dbl [500]&gt; 0.502 0.00459 0.493 0.511 Not Error\n 7             7 &lt;dbl [500]&gt; 0.509 0.00476 0.500 0.518 Not Error\n 8             8 &lt;dbl [500]&gt; 0.494 0.00451 0.486 0.503 Not Error\n 9             9 &lt;dbl [500]&gt; 0.499 0.00440 0.491 0.508 Not Error\n10            10 &lt;dbl [500]&gt; 0.497 0.00446 0.488 0.505 Not Error\n# ℹ 90 more rows"
  },
  {
    "objectID": "blog/posts/信頼区間を理解したい.html#各研究者の信頼区間を図示",
    "href": "blog/posts/信頼区間を理解したい.html#各研究者の信頼区間を図示",
    "title": "信頼区間を理解したい",
    "section": "各研究者の信頼区間を図示",
    "text": "各研究者の信頼区間を図示\n\n点推定値は0.5に近いのもあれば、遠いのもある\n信頼区間が真値（0.5）を含まない、「不運」な研究者は、5人 / 100人（5％）\n\n95％の研究者は真の値を拾える、という意味\n\n実際には自分が「不運」な研究者かもしれないし、信頼区間の端ギリギリで真値を拾っているだけかもしれない\n\n\n# 図示\ndata2 |&gt; \n  ggplot(aes(mean, researcher_ID, xmin = lower, xmax = upper, color = flg))+\n  geom_vline(xintercept = 0.5, linetype = 'dashed')+\n  geom_pointrange()+\n  theme_bw()+\n  theme(legend.position = 'bottom')"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "",
    "text": "ユークリッドの互除法は\n\n2つの自然数の最大公約数（GCD: Greatest Common Diviser）を求めるアルゴリズム\nそのために以下の性質を利用\n\n\\(a\\), \\(b\\)は自然数で\\(a \\neq 0\\)のとき\n等式：\\(a = bq + r\\)において，\\(\\mathrm{GCD}(a, b) = \\mathrm{GCD}(b, r)\\)が成り立つ\nこの性質を利用して，\n「\\(a\\)を\\(b\\)で割って余り\\(r_1\\)を算出」→「\\(b\\)を\\(r_1\\)で割って余り\\(r_2\\)を算出」→…\n→「\\(r_{n-1}\\)を\\(r_n\\)で割ると割り切れた」\n→\\(\\mathrm{GCD}(r_{n-1}, r_n) = \\mathrm{GCD}(r_{n-2}, n_{n-1})= ...=\\mathrm{GCD}(b, r_1) = \\mathrm{GCD}(a, b) = r_n\\)\nという形で最大公約数を求める"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#ユークリッドの互除法",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#ユークリッドの互除法",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "",
    "text": "ユークリッドの互除法は\n\n2つの自然数の最大公約数（GCD: Greatest Common Diviser）を求めるアルゴリズム\nそのために以下の性質を利用\n\n\\(a\\), \\(b\\)は自然数で\\(a \\neq 0\\)のとき\n等式：\\(a = bq + r\\)において，\\(\\mathrm{GCD}(a, b) = \\mathrm{GCD}(b, r)\\)が成り立つ\nこの性質を利用して，\n「\\(a\\)を\\(b\\)で割って余り\\(r_1\\)を算出」→「\\(b\\)を\\(r_1\\)で割って余り\\(r_2\\)を算出」→…\n→「\\(r_{n-1}\\)を\\(r_n\\)で割ると割り切れた」\n→\\(\\mathrm{GCD}(r_{n-1}, r_n) = \\mathrm{GCD}(r_{n-2}, n_{n-1})= ...=\\mathrm{GCD}(b, r_1) = \\mathrm{GCD}(a, b) = r_n\\)\nという形で最大公約数を求める"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#rで関数を実装",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#rで関数を実装",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "Rで関数を実装",
    "text": "Rで関数を実装\n\n関数定義\n\n\n# ユークリッドの互除法\ngcd &lt;- function(a, b){\n  if (!(a %% 1 == 0 & b %% 1 == 0 & a &gt; 0 & b &gt; 0)) {\n    cat('入力が自然数じゃないのでやり直し')\n  } \n  else if (a &lt; b) {\n    w &lt;- a\n    a &lt;- b\n    b &lt;- w\n  }\n  while (b != 0) {\n    r &lt;- a %% b\n    a &lt;- b\n    b &lt;- r\n  }\n  return(a)\n}\n\n\n実行結果\n\n\ngcd(50856, 96007)\n\n[1] 163"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#pythonで実装",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#pythonで実装",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "Pythonで実装",
    "text": "Pythonで実装\n\n関数定義\n\n\n# ユークリッドの互除法\ndef gcd(a, b):\n  if not (a % 1 == 0 and b % 1 == 0 and a &gt; 0 and b &gt; 0):\n    print('入力が自然数じゃないのでやり直し')\n  elif a &lt; b:\n    w = a\n    a = b\n    b = w\n  while not b == 0:\n    r = a % b\n    a = b\n    b = r\n  else:\n    return(a)\n\n\n実行結果\n\n\ngcd(50856, 96007)\n\n163"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#両言語の比較",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#両言語の比較",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "両言語の比較",
    "text": "両言語の比較\n\n1. 制御構文\n\n\n\n動作\nR\nPython\n\n\n\n\n関数定義\nname &lt;- function(引数){処理}\ndef name(引数):処理\n\n\n条件分岐1\nif(条件式){処理}\nif 条件式:処理\n\n\n条件分岐2\nelse if(条件式){処理}\nelif 条件式:処理\n\n\n繰り返し\nwhile(条件式){処理}\nwhile 条件式:処理\n\n\n\n\n\n2. 演算子など\n\n\n\n動作\nR\nPython\n\n\n\n\n整数商\n%/%\n//\n\n\n剰余\n%%\n%\n\n\n論理積\n&\nand\n\n\n論理和\n|\nor\n\n\n否定\n!\nnot\n\n\n\nRでは一貫して記号で演算子が与えられている一方， Pythonは条件分岐に関わる部分はアルファベットが用いられている。\nRの論理演算子がfilter処理とかで多用されることがイメージされている一方， Pythonはもっぱら条件分岐での使用がイメージされてそう？ （if not ～とかは自然に読みやすいけど，filter(a == 1 and b &lt;= 3 and ～)は長くなって読みにくいみたいな）"
  },
  {
    "objectID": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#追記",
    "href": "blog/posts/RとPython書き比べ（ユークリッドの互除法）.html#追記",
    "title": "RとPython書き比べ（ユークリッドの互除法）",
    "section": "追記",
    "text": "追記\n\n制御フローの見直し\n\nR\n\n変数の代入の部分を;を用いて一列にできるらしい（やってることは変わらない）\nPythonみたいなa, b = b, aという書き方はできず，中間変数を使わざるを得ない\n\n\ngcd2 &lt;- function(a, b){\n  if (!(a %% 1 == 0 & b %% 1 == 0 & a &gt; 0 & b &gt; 0)) {\n    cat('入力が自然数じゃないのでやり直し')\n  } \n  else {\n    if(a &lt; b){\n      tmp &lt;- a; a &lt;- b; b &lt;- tmp\n    }\n    while(b != 0){\n      r &lt;- a %% b; a &lt;- b; b &lt;- r \n    }\n    return(a)\n  }\n}\n\n\n\nPython\n\na, b = b, aという記法が大変便利。スワップ処理とかで中間変数が必要ない。\n\n\ndef gcd2(a, b):\n  if not (a % 1 == 0 and b % 1 == 0 and a &gt; 0 and b &gt; 0):\n    print('入力が自然数じゃないのでやり直し')\n  else:\n    if a &lt; b:\n      a, b = b, a\n    while a % b != 0:\n      a, b = b, a % b\n    else:\n      return b\n\n\n\n\n再帰関数を用いた実装\n再帰関数をコメントで教えてもらったので実装してみた。\n注意点として，b == 0になるまで繰り返してしまうと，引数が自然数という条件に反してしまうので，その一回前（a % b == 0）まで繰り返すように書き換える必要がある。\n\nPython\n\n\ndef gcd3(a,b):\n  if not (a % 1 == 0 and b % 1 == 0 and a &gt; 0 and b &gt; 0):\n    print('入力が自然数じゃないのでやり直し')\n  else:\n    if a &lt; b:\n      a, b = b, a\n    if not a % b == 0:\n      return gcd3(b, a % b)\n    else:\n      return b\n\n\ngcd(50856, 96007)\n\n163\n\ngcd2(50856, 96007)\n\n163\n\ngcd3(50856, 96007)\n\n163\n\n\n\nR\n\n再帰関数を呼び出す用のRecallという関数もある\n\ngcd3 &lt;- function(a, b){\n  if (!(a %% 1 == 0 & b %% 1 == 0 & a &gt; 0 & b &gt; 0)) {\n    cat('入力が自然数じゃないのでやり直し')\n  } \n  else {\n    if (a &lt; b) {\n      tmp &lt;- a; a &lt;- b; b &lt;- tmp\n    }\n    if (a %% b != 0) {\n      return(Recall(b, a %% b)) # またはgcd(b, a %% b)\n    }\n    else return(b)\n  }\n}\n\n\ngcd(50856, 96007)\n\n[1] 163\n\ngcd2(50856, 96007)\n\n[1] 163\n\ngcd3(50856, 96007)\n\n[1] 163"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "信頼区間を理解したい\n\n\n\nStatistics\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nSep 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nPIAAC、PISAの標準誤差\n\n\n\nStatistics\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nSep 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nBorusyak et al. (2024)\n\n\n\nCausal Inference\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nAug 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n複利計算\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nAug 15, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nマルチアンサーの処理\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nJun 5, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nバージョンを指定したRのインストール\n\n\n\nR\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nApr 30, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nBLASの変更によるRの高速化\n\n\n\nR\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nMar 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ntensorflowをRstudioで\n\n\n\nR Tips\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n観測度数・期待度数から対数尤度を計算する方法\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLongitudinal TMLE\n\n\n\nCausal Inference\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nSudharsanan & Bijlsma (2021)\n\n\n\nCausal Inference\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nrlang学習\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nCausal Decomposition Analysis\n\n\n\nCausal Inference\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nマルチレベルモデルは点推定値に影響を及ぼすか？\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nTargeted Maximum Likelihood Estimation / Targeted Minimum Loss-based Estimation (TMLE)\n\n\n\nCausal Inference\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n学生生活実態調査の文字コード\n\n\n\nOthers\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nJun 25, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n新しいパソコンを買ったらやること\n\n\n\nSetup\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nFeb 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nZoteroの設定備忘録\n\n\n\nSetup\n\n\nZotero\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nJun 5, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nRでロジットモデル\n\n\n\nStatistics\n\n\nR\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nApr 29, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n移動平均のかゆいところに，partial = TRUE\n\n\n\nR\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nOct 25, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nRとPython書き比べ（ユークリッドの互除法）\n\n\n\nR\n\n\nPython\n\n\n\n\n\n\n\nKentaro Kamada\n\n\nJul 31, 2020\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "鎌田 健太郎（Kentaro Kamada）",
    "section": "",
    "text": "東京大学大学院教育学研究科比較教育社会学コース 博士課程・日本学術振興会 特別研究員（DC1）"
  },
  {
    "objectID": "profile.html",
    "href": "profile.html",
    "title": "Profile",
    "section": "",
    "text": "2023年4月 - 現在：独立行政法人日本学術振興会 特別研究員（DC1）\n2021年4月 - 現在：東京大学社会科学研究所 附属社会調査・データアーカイブ研究センター 学術専門職員"
  },
  {
    "objectID": "profile.html#職歴",
    "href": "profile.html#職歴",
    "title": "Profile",
    "section": "",
    "text": "2023年4月 - 現在：独立行政法人日本学術振興会 特別研究員（DC1）\n2021年4月 - 現在：東京大学社会科学研究所 附属社会調査・データアーカイブ研究センター 学術専門職員"
  },
  {
    "objectID": "profile.html#学歴",
    "href": "profile.html#学歴",
    "title": "Profile",
    "section": "学歴",
    "text": "学歴\n\n2023年4月 - 現在：東京大学大学院教育学研究科比較教育社会学コース 博士課程\n2021年4月 - 2023年3月：東京大学大学院教育学研究科 比較教育社会学コース 修士課程\n2019年4月 - 2021年3月：東京大学教育学部 比較教育社会学コース"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Research",
    "section": "",
    "text": "鎌田健太郎，2024，「初年次教育の導入・改革は学生の学習を促進したか——国立総合大学における因果効果の検討」『教育学研究』91(1): 1–12．\n\n Appendix  再現コード\n\n鎌田健太郎，2022，「高等教育再拡大期における学生活動の変化——Typological Approach による学生下位集団の時代比較」『高等教育研究』25: 257–74．"
  },
  {
    "objectID": "research.html#査読付き論文",
    "href": "research.html#査読付き論文",
    "title": "Research",
    "section": "",
    "text": "鎌田健太郎，2024，「初年次教育の導入・改革は学生の学習を促進したか——国立総合大学における因果効果の検討」『教育学研究』91(1): 1–12．\n\n Appendix  再現コード\n\n鎌田健太郎，2022，「高等教育再拡大期における学生活動の変化——Typological Approach による学生下位集団の時代比較」『高等教育研究』25: 257–74．"
  },
  {
    "objectID": "blog/posts/度数から対数尤度を計算.html",
    "href": "blog/posts/度数から対数尤度を計算.html",
    "title": "観測度数・期待度数から対数尤度を計算する方法",
    "section": "",
    "text": "\\(f_{ij}\\)：観測度数\n\n\n\n\n\nB\nB’\n\n\n\n\nA\n\\(f_{11}\\)\n\\(f_{12}\\)\n\n\nA’\n\\(f_{21}\\)\n\\(f_{22}\\)\n\n\n\n\n\\(p_{ij}\\)：セル確率\n\nモデルから計算されたセルの確率\nAとBに関連がないモデルにおいては、期待度数をサンプルサイズで割ったもの\n\n\n\n\n\n\nB\nB’\n\n\n\n\nA\n\\(p_{11}\\)\n\\(p_{12}\\)\n\n\nA’\n\\(p_{21}\\)\n\\(p_{22}\\)\n\n\n\n尤度関数を\\(L\\)とすると\n\\[\nL = \\prod_i \\prod_j p_{ij}^{f_{ij}} =  p_{11}^{f_{11}} \\times p_{12}^{f_{12}} \\times p_{21}^{f_{21}} \\times p_{22}^{f_{22}}\n\\]\n各セルの確率を(観測度数)乗したものを全部掛け算\n対数尤度はこれの対数を取ったもの\n\\[\n\\log L = \\sum_i \\sum_j f_{ij} \\log p_{ij} = f_{11} \\log p_{11} + f_{12} \\log p_{12} + f_{21} \\log p_{21} + f_{22} \\log p_{22}\n\\]\n掛け算が足し算になるので計算しやすい"
  },
  {
    "objectID": "blog/posts/度数から対数尤度を計算.html#観測度数とセル確率から対数尤度を計算",
    "href": "blog/posts/度数から対数尤度を計算.html#観測度数とセル確率から対数尤度を計算",
    "title": "観測度数・期待度数から対数尤度を計算する方法",
    "section": "",
    "text": "\\(f_{ij}\\)：観測度数\n\n\n\n\n\nB\nB’\n\n\n\n\nA\n\\(f_{11}\\)\n\\(f_{12}\\)\n\n\nA’\n\\(f_{21}\\)\n\\(f_{22}\\)\n\n\n\n\n\\(p_{ij}\\)：セル確率\n\nモデルから計算されたセルの確率\nAとBに関連がないモデルにおいては、期待度数をサンプルサイズで割ったもの\n\n\n\n\n\n\nB\nB’\n\n\n\n\nA\n\\(p_{11}\\)\n\\(p_{12}\\)\n\n\nA’\n\\(p_{21}\\)\n\\(p_{22}\\)\n\n\n\n尤度関数を\\(L\\)とすると\n\\[\nL = \\prod_i \\prod_j p_{ij}^{f_{ij}} =  p_{11}^{f_{11}} \\times p_{12}^{f_{12}} \\times p_{21}^{f_{21}} \\times p_{22}^{f_{22}}\n\\]\n各セルの確率を(観測度数)乗したものを全部掛け算\n対数尤度はこれの対数を取ったもの\n\\[\n\\log L = \\sum_i \\sum_j f_{ij} \\log p_{ij} = f_{11} \\log p_{11} + f_{12} \\log p_{12} + f_{21} \\log p_{21} + f_{22} \\log p_{22}\n\\]\n掛け算が足し算になるので計算しやすい"
  },
  {
    "objectID": "blog/posts/度数から対数尤度を計算.html#尤度比カイ2乗値との関係",
    "href": "blog/posts/度数から対数尤度を計算.html#尤度比カイ2乗値との関係",
    "title": "観測度数・期待度数から対数尤度を計算する方法",
    "section": "尤度比カイ2乗値との関係",
    "text": "尤度比カイ2乗値との関係\n尤度比カイ2乗値（\\(G^2\\)）と観測度数（\\(f\\)）・期待度数（\\(F\\)）の関係は以下の式で表される(Hout 1983; McCutcheon 1987)\n\\[\nG^2 = 2 \\sum_i \\sum_j f_{ij} \\log \\frac{f_{ij}}{F_{ij}}\n\\]\nなぜこうなるのか？対数尤度の比から考えてみる。\nまず、AとBに関連がないというモデル（独立モデル）のもとで対数尤度を計算する。この条件ではセル確率\\(p_{ij}\\)は期待度数\\(F_{ij}\\)をサンプルサイズ\\(N\\)で割ったものになる。\n\\[\n\\log L_1 = \\sum_i \\sum_j f_{ij} \\log p_{ij} = \\sum_i \\sum_j f_{ij} \\log \\frac{F_{ij}}{N} = \\sum_i \\sum_j f_{ij} \\log F_{ij} - \\sum_i \\sum_j f_{ij} \\log N\n\\]\n次に、AとBに関連があるというモデル（飽和モデル）のもとで対数尤度を計算する。この条件ではセル確率\\(p_{ij}\\)は観測度数\\(f_{ij}\\)をサンプルサイズ\\(N\\)で割ったものになる。\n\\[\n\\log L_2 = \\sum_i \\sum_j f_{ij} \\log p_{ij} = \\sum_i \\sum_j f_{ij} \\log \\frac{f_{ij}}{N} = \\sum_i \\sum_j f_{ij} \\log f_{ij} - \\sum_i \\sum_j f_{ij} \\log N\n\\]\n対数尤度の差（＝尤度の比）を計算すると\n\\[\\begin{align}\n\\log L_2 - \\log L_1 &= \\sum_i \\sum_j f_{ij} \\log f_{ij} - \\sum_i \\sum_j f_{ij} \\log F_{ij} \\\\\n\\log \\frac{L_2}{L_1} &= \\sum_i \\sum_j (f_{ij} \\log f_{ij} - f_{ij} \\log F_{ij}) \\\\\n\\log \\frac{L_2}{L_1} &= \\sum_i \\sum_j f_{ij} \\log \\frac{f_{ij}}{F_{ij}} \\\\\n\\end{align}\\]\nそれっぽい形になった。\nさらに両辺を2倍すると\n\\[\n2 \\log \\frac{L_2}{L_1} = \\log (\\frac{L_2}{L_1})^2 = 2 \\sum_i \\sum_j f_{ij} \\log \\frac{f_{ij}}{F_{ij}}\n\\]\nしたがって尤度比カイ二乗値は、尤度比の2乗の対数をとったものである。\nあるいは、以下のように変形すればdeviance（-2対数尤度）の差としても表現できる。\n\\[\n2 \\log \\frac{L_2}{L_1} = (-2 \\log L_1) - (- 2 \\log L_2)\n\\]"
  },
  {
    "objectID": "blog/posts/L-TMLE.html",
    "href": "blog/posts/L-TMLE.html",
    "title": "Longitudinal TMLE",
    "section": "",
    "text": "Hernán and Robins (2020) では、TMLEは時間依存交絡などに対処するG-Methodの一般化として提示されている。ここではltmleパッケージを用いた時間依存交絡への対処を中心に記述する。\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(SuperLearner)\nlibrary(ltmle)\nlibrary(randomForest)\nlibrary(ggdag)\nlibrary(future)\n\nkable &lt;- partial(\n  knitr::kable,\n  digits = 3\n)\n\noptions(mc.cores = 8)\nplan(strategy = 'multisession')\n\nset.seed(95)\n\n\n\n\n以下のDAGを考える\n\ndagify(\n  L1 ~ A0 + U1,\n  A1 ~ A0 + L1,\n  Y ~ U1,\n  exposure = c('A0', 'A1'), \n  outcome = 'Y', \n  coords = list(x = c(A0 = 0, L1 = 1, A1 = 2, U1 = 1, Y = 3),\n                y = c(A0 = 0, L1 = 0, A1 = 0, U1 = -1, Y = 0))\n) |&gt; \n  ggdag()+\n  theme_dag()\n\n\n\n\n\n\n\n\nTreatmentはA0とA1であるが、ここからYへのpathはないので、因果効果は全ての組み合わせについて0になる\n具体的には、potential outcomeのすべての組み合わせについて、差分を取った値が0になる\n\\[\\begin{align}\n\\mathrm{E}[Y^{0, 0} - Y^{1, 0}] &= 0\\\\\n\\mathrm{E}[Y^{0, 0} - Y^{0, 1}] &= 0\\\\\n\\mathrm{E}[Y^{0, 0} - Y^{1, 1}] &= 0\\\\\n\\mathrm{E}[Y^{1, 0} - Y^{0, 1}] &= 0\\\\\n\\mathrm{E}[Y^{1, 0} - Y^{1, 1}] &= 0\\\\\n\\mathrm{E}[Y^{0, 1} - Y^{1, 1}] &= 0\n\\end{align}\\]\n\ngenerate_data &lt;- function(n){ \n    A0 &lt;- rbinom(n, size=1, prob=0.3) # binary treatment\n    U1 &lt;- rnorm(n, mean = 0, sd = 1) # latent continuous confounder\n    L1 &lt;- 0.1 + 0.3*A0 + 0.3*U1 + rnorm(n, sd = 0.1)\n    A1 &lt;- rbinom(n, size=1, prob = plogis(-0.2 + 0.3*L1 + 0.02*L1^2)) # binary treatment\n    Y &lt;- -0.2 + 0.5*U1 + rnorm(n, sd = 0.1) # continuous outcome depends on confounders\n    return(tibble(Y, A0, A1, L1, U1))\n}\n\ndata_obs &lt;- generate_data(1000)\n\n\nA0の因果効果\n\n\ndata_obs |&gt; \n  lm(Y ~ A0, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.207\n0.019\n-10.925\n0.000\n\n\nA0\n0.029\n0.036\n0.804\n0.422\n\n\n\n\n\n\nA1の因果効果\n\n\ndata_obs |&gt; \n  lm(Y ~ A1 + L1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.427\n0.012\n-34.532\n0.000\n\n\nA1\n-0.017\n0.017\n-1.020\n0.308\n\n\nL1\n1.275\n0.025\n51.719\n0.000\n\n\n\n\n\n\ncollider bias\n\n\\(L_1\\)を条件づけると、\\(A_0 \\to L_1 \\gets U_1 \\to Y\\)というパスが開いて、バイアスをもたらす\n\ndata_obs |&gt; \n  lm(Y ~ A0 + L1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.352\n0.007\n-49.626\n0\n\n\nA0\n-0.469\n0.014\n-32.796\n0\n\n\nL1\n1.540\n0.019\n81.391\n0\n\n\n\n\n\n\ndata_obs |&gt; \n  lm(Y ~ A0*A1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.217\n0.026\n-8.364\n0.000\n\n\nA0\n0.043\n0.051\n0.859\n0.390\n\n\nA1\n0.021\n0.038\n0.559\n0.576\n\n\nA0:A1\n-0.031\n0.072\n-0.428\n0.669\n\n\n\n\n\n\n\n\n\nHernán and Robins (2020) にて紹介されている方法\n以下のウェイトを作成する\n\\[\nW^{A_0, A_1} = \\frac{1}{f(A_0 | L_0)} \\times \\frac{1}{f(A_1 | A_0, L_0, L_1)}\n\\]\n今回はベースライン共変量がない（\\(L_0 = \\varnothing\\)）ので\n\\[\nW^{A_0, A_1} = \\frac{1}{f(A_0)} \\times \\frac{1}{f(A_1 | A_0, L_1)}\n\\]\n\nres_ipw &lt;-\n  broom::augment_columns(\n    glm(A0 ~ 1, data = data_obs, family = 'binomial'), \n    data = data_obs, \n    type.predict = 'response'\n  ) |&gt; \n  # A0に対するウェイト\n  mutate(\n    ipw_A0 = case_when(\n      A0 == 1 ~ 1 / .fitted,\n      A0 == 0 ~ 1 / (1 - .fitted)\n    )\n  ) |&gt; \n  select(Y:U1, ipw_A0) |&gt; \n  broom::augment_columns(\n    glm(A1 ~ A0 + L1 + I(L1^2), data = data_obs, family = 'binomial'),\n    data = _,\n    type.predict = 'response'\n  ) |&gt; \n  mutate(\n    # A1に対するウェイト\n    ipw_A1 = case_when(\n      A1 == 1 ~ 1 / .fitted,\n      A1 == 0 ~ 1 / (1 - .fitted)\n    )\n  ) |&gt; \n  select(Y:U1, ipw_A0, ipw_A1) |&gt; \n  # A0に対するウェイトとA1に対するウェイトをかけ算\n  mutate(ipw = ipw_A0*ipw_A1) |&gt; \n  # 重み付け推定\n  summarise(CFmean = weighted.mean(Y, ipw), .by = c(A0, A1)) |&gt; \n  arrange(A0, A1)\n\nipwによる各treatment strategyにおけるcounterfactual mean\n\nres_ipw\n\n# A tibble: 4 × 3\n     A0    A1 CFmean\n  &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;\n1     0     0 -0.208\n2     0     1 -0.207\n3     1     0 -0.166\n4     1     1 -0.189\n\n\ncounterfactual meanの差分\n\ncross_join(\n  res_ipw |&gt; \n    mutate(A0_A1 = str_c(A0, ',', A1)) |&gt; \n    select(A0_A1, CFmean),\n  res_ipw |&gt; \n    mutate(A0_A1 = str_c(A0, ',', A1)) |&gt; \n    select(A0_A1, CFmean)\n  ) |&gt; \n  filter(A0_A1.x != A0_A1.y) |&gt; \n  mutate(ATE = CFmean.y - CFmean.x)\n\n# A tibble: 12 × 5\n   A0_A1.x CFmean.x A0_A1.y CFmean.y       ATE\n   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n 1 0,0       -0.208 0,1       -0.207  0.000654\n 2 0,0       -0.208 1,0       -0.166  0.0419  \n 3 0,0       -0.208 1,1       -0.189  0.0190  \n 4 0,1       -0.207 0,0       -0.208 -0.000654\n 5 0,1       -0.207 1,0       -0.166  0.0412  \n 6 0,1       -0.207 1,1       -0.189  0.0184  \n 7 1,0       -0.166 0,0       -0.208 -0.0419  \n 8 1,0       -0.166 0,1       -0.207 -0.0412  \n 9 1,0       -0.166 1,1       -0.189 -0.0229  \n10 1,1       -0.189 0,0       -0.208 -0.0190  \n11 1,1       -0.189 0,1       -0.207 -0.0184  \n12 1,1       -0.189 1,0       -0.166  0.0229  \n\n\n\n\n\n\nltmleによる実装\n\n\nres_tmle &lt;- \n  ltmle::ltmle(\n    # データセットの列の順番が大切\n    data = data_obs |&gt; select(A0, L1, A1, Y), \n    Anodes = c('A0', 'A1'), \n    Lnodes = 'L1',\n    Ynodes = 'Y',\n    abar = list(treatment = c(1, 1), control = c(0, 0)), \n    SL.library = c('SL.glm', 'SL.gam', 'SL.randomForest')\n  )\n\n\nsummary(res_tmle)\n\nEstimator:  tmle \nCall:\nltmle::ltmle(data = select(data_obs, A0, L1, A1, Y), Anodes = c(\"A0\", \n    \"A1\"), Lnodes = \"L1\", Ynodes = \"Y\", abar = list(treatment = c(1, \n    1), control = c(0, 0)), SL.library = c(\"SL.glm\", \"SL.gam\", \n    \"SL.randomForest\"))\n\nTreatment Estimate:\n   Parameter Estimate:  -0.17554 \n    Estimated Std Err:  0.033541 \n              p-value:  &lt;2e-16 \n    95% Conf Interval: (-0.24128, -0.1098) \n\nControl Estimate:\n   Parameter Estimate:  -0.20361 \n    Estimated Std Err:  0.019777 \n              p-value:  &lt;2e-16 \n    95% Conf Interval: (-0.24237, -0.16485) \n\nAdditive Treatment Effect:\n   Parameter Estimate:  0.028069 \n    Estimated Std Err:  0.038937 \n              p-value:  0.47099 \n    95% Conf Interval: (-0.048247, 0.10438) \n\n\n\n\n\nltmleはメジャー（？）だが、あんまり汎用性が高いと言えず、開発も盛んなようには見えない。ほかにlongitudinal TMLEを実装しているパッケージとしてlmtpやstremrがある。lmtpはCRANにも登録してあり、試してみる価値あり。stremrはさまざまなアプローチの統合を目指す非常に意欲的なパッケージだが、開発は止まっている？っぽい。"
  },
  {
    "objectID": "blog/posts/L-TMLE.html#下準備",
    "href": "blog/posts/L-TMLE.html#下準備",
    "title": "Longitudinal TMLE",
    "section": "",
    "text": "library(tidyverse)\nlibrary(broom)\nlibrary(SuperLearner)\nlibrary(ltmle)\nlibrary(randomForest)\nlibrary(ggdag)\nlibrary(future)\n\nkable &lt;- partial(\n  knitr::kable,\n  digits = 3\n)\n\noptions(mc.cores = 8)\nplan(strategy = 'multisession')\n\nset.seed(95)\n\n\n\n\n以下のDAGを考える\n\ndagify(\n  L1 ~ A0 + U1,\n  A1 ~ A0 + L1,\n  Y ~ U1,\n  exposure = c('A0', 'A1'), \n  outcome = 'Y', \n  coords = list(x = c(A0 = 0, L1 = 1, A1 = 2, U1 = 1, Y = 3),\n                y = c(A0 = 0, L1 = 0, A1 = 0, U1 = -1, Y = 0))\n) |&gt; \n  ggdag()+\n  theme_dag()\n\n\n\n\n\n\n\n\nTreatmentはA0とA1であるが、ここからYへのpathはないので、因果効果は全ての組み合わせについて0になる\n具体的には、potential outcomeのすべての組み合わせについて、差分を取った値が0になる\n\\[\\begin{align}\n\\mathrm{E}[Y^{0, 0} - Y^{1, 0}] &= 0\\\\\n\\mathrm{E}[Y^{0, 0} - Y^{0, 1}] &= 0\\\\\n\\mathrm{E}[Y^{0, 0} - Y^{1, 1}] &= 0\\\\\n\\mathrm{E}[Y^{1, 0} - Y^{0, 1}] &= 0\\\\\n\\mathrm{E}[Y^{1, 0} - Y^{1, 1}] &= 0\\\\\n\\mathrm{E}[Y^{0, 1} - Y^{1, 1}] &= 0\n\\end{align}\\]\n\ngenerate_data &lt;- function(n){ \n    A0 &lt;- rbinom(n, size=1, prob=0.3) # binary treatment\n    U1 &lt;- rnorm(n, mean = 0, sd = 1) # latent continuous confounder\n    L1 &lt;- 0.1 + 0.3*A0 + 0.3*U1 + rnorm(n, sd = 0.1)\n    A1 &lt;- rbinom(n, size=1, prob = plogis(-0.2 + 0.3*L1 + 0.02*L1^2)) # binary treatment\n    Y &lt;- -0.2 + 0.5*U1 + rnorm(n, sd = 0.1) # continuous outcome depends on confounders\n    return(tibble(Y, A0, A1, L1, U1))\n}\n\ndata_obs &lt;- generate_data(1000)\n\n\nA0の因果効果\n\n\ndata_obs |&gt; \n  lm(Y ~ A0, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.207\n0.019\n-10.925\n0.000\n\n\nA0\n0.029\n0.036\n0.804\n0.422\n\n\n\n\n\n\nA1の因果効果\n\n\ndata_obs |&gt; \n  lm(Y ~ A1 + L1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.427\n0.012\n-34.532\n0.000\n\n\nA1\n-0.017\n0.017\n-1.020\n0.308\n\n\nL1\n1.275\n0.025\n51.719\n0.000\n\n\n\n\n\n\ncollider bias\n\n\\(L_1\\)を条件づけると、\\(A_0 \\to L_1 \\gets U_1 \\to Y\\)というパスが開いて、バイアスをもたらす\n\ndata_obs |&gt; \n  lm(Y ~ A0 + L1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.352\n0.007\n-49.626\n0\n\n\nA0\n-0.469\n0.014\n-32.796\n0\n\n\nL1\n1.540\n0.019\n81.391\n0\n\n\n\n\n\n\ndata_obs |&gt; \n  lm(Y ~ A0*A1, data = _) |&gt; \n  tidy() |&gt; \n  kable()\n\n\n\n\nterm\nestimate\nstd.error\nstatistic\np.value\n\n\n\n\n(Intercept)\n-0.217\n0.026\n-8.364\n0.000\n\n\nA0\n0.043\n0.051\n0.859\n0.390\n\n\nA1\n0.021\n0.038\n0.559\n0.576\n\n\nA0:A1\n-0.031\n0.072\n-0.428\n0.669"
  },
  {
    "objectID": "blog/posts/L-TMLE.html#ipw",
    "href": "blog/posts/L-TMLE.html#ipw",
    "title": "Longitudinal TMLE",
    "section": "",
    "text": "Hernán and Robins (2020) にて紹介されている方法\n以下のウェイトを作成する\n\\[\nW^{A_0, A_1} = \\frac{1}{f(A_0 | L_0)} \\times \\frac{1}{f(A_1 | A_0, L_0, L_1)}\n\\]\n今回はベースライン共変量がない（\\(L_0 = \\varnothing\\)）ので\n\\[\nW^{A_0, A_1} = \\frac{1}{f(A_0)} \\times \\frac{1}{f(A_1 | A_0, L_1)}\n\\]\n\nres_ipw &lt;-\n  broom::augment_columns(\n    glm(A0 ~ 1, data = data_obs, family = 'binomial'), \n    data = data_obs, \n    type.predict = 'response'\n  ) |&gt; \n  # A0に対するウェイト\n  mutate(\n    ipw_A0 = case_when(\n      A0 == 1 ~ 1 / .fitted,\n      A0 == 0 ~ 1 / (1 - .fitted)\n    )\n  ) |&gt; \n  select(Y:U1, ipw_A0) |&gt; \n  broom::augment_columns(\n    glm(A1 ~ A0 + L1 + I(L1^2), data = data_obs, family = 'binomial'),\n    data = _,\n    type.predict = 'response'\n  ) |&gt; \n  mutate(\n    # A1に対するウェイト\n    ipw_A1 = case_when(\n      A1 == 1 ~ 1 / .fitted,\n      A1 == 0 ~ 1 / (1 - .fitted)\n    )\n  ) |&gt; \n  select(Y:U1, ipw_A0, ipw_A1) |&gt; \n  # A0に対するウェイトとA1に対するウェイトをかけ算\n  mutate(ipw = ipw_A0*ipw_A1) |&gt; \n  # 重み付け推定\n  summarise(CFmean = weighted.mean(Y, ipw), .by = c(A0, A1)) |&gt; \n  arrange(A0, A1)\n\nipwによる各treatment strategyにおけるcounterfactual mean\n\nres_ipw\n\n# A tibble: 4 × 3\n     A0    A1 CFmean\n  &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;\n1     0     0 -0.208\n2     0     1 -0.207\n3     1     0 -0.166\n4     1     1 -0.189\n\n\ncounterfactual meanの差分\n\ncross_join(\n  res_ipw |&gt; \n    mutate(A0_A1 = str_c(A0, ',', A1)) |&gt; \n    select(A0_A1, CFmean),\n  res_ipw |&gt; \n    mutate(A0_A1 = str_c(A0, ',', A1)) |&gt; \n    select(A0_A1, CFmean)\n  ) |&gt; \n  filter(A0_A1.x != A0_A1.y) |&gt; \n  mutate(ATE = CFmean.y - CFmean.x)\n\n# A tibble: 12 × 5\n   A0_A1.x CFmean.x A0_A1.y CFmean.y       ATE\n   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n 1 0,0       -0.208 0,1       -0.207  0.000654\n 2 0,0       -0.208 1,0       -0.166  0.0419  \n 3 0,0       -0.208 1,1       -0.189  0.0190  \n 4 0,1       -0.207 0,0       -0.208 -0.000654\n 5 0,1       -0.207 1,0       -0.166  0.0412  \n 6 0,1       -0.207 1,1       -0.189  0.0184  \n 7 1,0       -0.166 0,0       -0.208 -0.0419  \n 8 1,0       -0.166 0,1       -0.207 -0.0412  \n 9 1,0       -0.166 1,1       -0.189 -0.0229  \n10 1,1       -0.189 0,0       -0.208 -0.0190  \n11 1,1       -0.189 0,1       -0.207 -0.0184  \n12 1,1       -0.189 1,0       -0.166  0.0229"
  },
  {
    "objectID": "blog/posts/L-TMLE.html#longitudinal-tmle",
    "href": "blog/posts/L-TMLE.html#longitudinal-tmle",
    "title": "Longitudinal TMLE",
    "section": "",
    "text": "ltmleによる実装\n\n\nres_tmle &lt;- \n  ltmle::ltmle(\n    # データセットの列の順番が大切\n    data = data_obs |&gt; select(A0, L1, A1, Y), \n    Anodes = c('A0', 'A1'), \n    Lnodes = 'L1',\n    Ynodes = 'Y',\n    abar = list(treatment = c(1, 1), control = c(0, 0)), \n    SL.library = c('SL.glm', 'SL.gam', 'SL.randomForest')\n  )\n\n\nsummary(res_tmle)\n\nEstimator:  tmle \nCall:\nltmle::ltmle(data = select(data_obs, A0, L1, A1, Y), Anodes = c(\"A0\", \n    \"A1\"), Lnodes = \"L1\", Ynodes = \"Y\", abar = list(treatment = c(1, \n    1), control = c(0, 0)), SL.library = c(\"SL.glm\", \"SL.gam\", \n    \"SL.randomForest\"))\n\nTreatment Estimate:\n   Parameter Estimate:  -0.17554 \n    Estimated Std Err:  0.033541 \n              p-value:  &lt;2e-16 \n    95% Conf Interval: (-0.24128, -0.1098) \n\nControl Estimate:\n   Parameter Estimate:  -0.20361 \n    Estimated Std Err:  0.019777 \n              p-value:  &lt;2e-16 \n    95% Conf Interval: (-0.24237, -0.16485) \n\nAdditive Treatment Effect:\n   Parameter Estimate:  0.028069 \n    Estimated Std Err:  0.038937 \n              p-value:  0.47099 \n    95% Conf Interval: (-0.048247, 0.10438)"
  },
  {
    "objectID": "blog/posts/L-TMLE.html#他のパッケージ",
    "href": "blog/posts/L-TMLE.html#他のパッケージ",
    "title": "Longitudinal TMLE",
    "section": "",
    "text": "ltmleはメジャー（？）だが、あんまり汎用性が高いと言えず、開発も盛んなようには見えない。ほかにlongitudinal TMLEを実装しているパッケージとしてlmtpやstremrがある。lmtpはCRANにも登録してあり、試してみる価値あり。stremrはさまざまなアプローチの統合を目指す非常に意欲的なパッケージだが、開発は止まっている？っぽい。"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html",
    "href": "blog/posts/新しいパソコンを買ったらやること.html",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "Office365のインストール\nOnedriveのインストール\n\n特に問題なくできた\n\n\n\n\n定番のパッケージマネージャー\n\n[https://brew.sh/index_ja:embed:cite]\n\n\n\n\nR本体のインストール\n\nrigというツールを使う。参考\nbrew tap r-lib/rig\nbrew install --cask rig \nrig add 4.3.3\n\nRstudioのインストール\n\nbrew install --cask rstudio\n\n自作したRstudioテーマを持ってくる（あとでgithubにでも置いておく）\nエディタで使用するフォントを選択\n\nmyricaを使いたかったが，なぜかMacだとうまくいっていない（調査中）\n\nRtools（Windows）or Xcode（Mac）のインストール\n\ngithub産のパッケージのビルドなどに必要\n\n（Macのみ）Xquartzのインストール\n\n詳しくはわからないが，入れないとRmarkdownがちゃんと動かなかった\n\n\n\n\n\n\n（winのみ）gitをインストール\n\nmacだとgit自体がすでにインストールされていた\n\nssh keyの作成→githubへ登録\ngit clone で適宜必要なプロジェクトをダウンロード\n\n\n\n\n\ntinytexのインストール\ntinytex::install_tinytex()でtex本体をインストール\nlatex_engine: lualatexの文章を作成し，エラーを見ながら適宜tinytex::tlmgr_install()で足りないパッケージを追加\n\n（Mac）haranoajiで引っかかった\n\n\n\n\n\n\n同期の開始\n\n「環境設定」の「同期」からユーザー名，パスワードを打ち込んで同期を開始\n「詳細」→「ファイルとフォルダ」から，基本ディレクトリを正しく設定する→pdfファイルと文献情報が紐づいた形で設定が引き継がれる\n\n\nあとは以下を参考に設定する\n[https://sickle-sword.hatenablog.com/entry/2021/06/05/160818?_ga=2.261856205.1735845236.1644808541-16137706.1644808541:embed:cite]"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#office関連のインストール",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#office関連のインストール",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "Office365のインストール\nOnedriveのインストール\n\n特に問題なくできた"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#homebrewのインストールmac",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#homebrewのインストールmac",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "定番のパッケージマネージャー\n\n[https://brew.sh/index_ja:embed:cite]"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#r関連のインストール",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#r関連のインストール",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "R本体のインストール\n\nrigというツールを使う。参考\nbrew tap r-lib/rig\nbrew install --cask rig \nrig add 4.3.3\n\nRstudioのインストール\n\nbrew install --cask rstudio\n\n自作したRstudioテーマを持ってくる（あとでgithubにでも置いておく）\nエディタで使用するフォントを選択\n\nmyricaを使いたかったが，なぜかMacだとうまくいっていない（調査中）\n\nRtools（Windows）or Xcode（Mac）のインストール\n\ngithub産のパッケージのビルドなどに必要\n\n（Macのみ）Xquartzのインストール\n\n詳しくはわからないが，入れないとRmarkdownがちゃんと動かなかった"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#gitのインストール",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#gitのインストール",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "（winのみ）gitをインストール\n\nmacだとgit自体がすでにインストールされていた\n\nssh keyの作成→githubへ登録\ngit clone で適宜必要なプロジェクトをダウンロード"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#rmarkdown関連のインストール",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#rmarkdown関連のインストール",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "tinytexのインストール\ntinytex::install_tinytex()でtex本体をインストール\nlatex_engine: lualatexの文章を作成し，エラーを見ながら適宜tinytex::tlmgr_install()で足りないパッケージを追加\n\n（Mac）haranoajiで引っかかった"
  },
  {
    "objectID": "blog/posts/新しいパソコンを買ったらやること.html#zoteroのインストール",
    "href": "blog/posts/新しいパソコンを買ったらやること.html#zoteroのインストール",
    "title": "新しいパソコンを買ったらやること",
    "section": "",
    "text": "同期の開始\n\n「環境設定」の「同期」からユーザー名，パスワードを打ち込んで同期を開始\n「詳細」→「ファイルとフォルダ」から，基本ディレクトリを正しく設定する→pdfファイルと文献情報が紐づいた形で設定が引き継がれる\n\n\nあとは以下を参考に設定する\n[https://sickle-sword.hatenablog.com/entry/2021/06/05/160818?_ga=2.261856205.1735845236.1644808541-16137706.1644808541:embed:cite]"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html",
    "href": "blog/posts/Zoteroの設定備忘録.html",
    "title": "Zoteroの設定備忘録",
    "section": "",
    "text": "先日ようやく文献管理をはじめた．\n社会学周りだと，ここらへんのメソッドが全く確立されていない&共有されないので，試行錯誤が大変だった．\n以下では自分なりに見つけた方法をメモっていく．（メモらないと絶対忘れる）"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#ようやく始めた文献管理",
    "href": "blog/posts/Zoteroの設定備忘録.html#ようやく始めた文献管理",
    "title": "Zoteroの設定備忘録",
    "section": "",
    "text": "先日ようやく文献管理をはじめた．\n社会学周りだと，ここらへんのメソッドが全く確立されていない&共有されないので，試行錯誤が大変だった．\n以下では自分なりに見つけた方法をメモっていく．（メモらないと絶対忘れる）"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#zoteroのインストール",
    "href": "blog/posts/Zoteroの設定備忘録.html#zoteroのインストール",
    "title": "Zoteroの設定備忘録",
    "section": "Zoteroのインストール",
    "text": "Zoteroのインストール\nなにはともあれZotero本体のインストール．\n「zotero install」みたいな感じで適当にググったら出てくる． https://www.zotero.org/download/\nインストール時の注意とかも特になし．サクサク進める．"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#ブラウザコネクタのインストール",
    "href": "blog/posts/Zoteroの設定備忘録.html#ブラウザコネクタのインストール",
    "title": "Zoteroの設定備忘録",
    "section": "ブラウザコネクタのインストール",
    "text": "ブラウザコネクタのインストール\nZoteroを起動して「ツール」&gt;「ブラウザ・コネクタのインストール」をクリック．\nするとウェブブラウザが立ち上がるので，自分が使うブラウザのコネクタをインストールする．\nこれも作りが丁寧でわかりやすいのでサクサク進める．"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#はじめにやっとく設定",
    "href": "blog/posts/Zoteroの設定備忘録.html#はじめにやっとく設定",
    "title": "Zoteroの設定備忘録",
    "section": "はじめにやっとく設定",
    "text": "はじめにやっとく設定\n「編集」&gt;「設定」からやっておいた方がいい設定をいじる（Macだと「Zotero」&gt;「環境設定」）\n\n一般\n\n「ウェブページからアイテムを作成するときに自動的にスナップショットを作成する」のチェックを外す\nゴミ箱の中のアイテムを7日（お好きなように）経過で削除\n\n同期\n\nデータの同期，作ったアカウントでログインしておく\nファイルの同期，すべてチェックを外す（pdfはOnedriveに保存するので使わない）\n\n詳細\n\nファイルとフォルダ，リンク付き添付ファイルの基本ディレクトリを，pdfを保存したいディレクトリに設定する（自分の場合はOnedrive&gt;Zotero）"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#アドオンのインストール",
    "href": "blog/posts/Zoteroの設定備忘録.html#アドオンのインストール",
    "title": "Zoteroの設定備忘録",
    "section": "アドオンのインストール",
    "text": "アドオンのインストール\nZoteroはオープンソースなので，便利なアドオンをいろんな人が作ってくれている．\n以下ではZotFileとBetter-BibTexの二つを導入する．\n\nZotFileの導入（Zotero 7では使えないので注意！）\n\nまずはアドオンをダウンロードしてくる．http://zotfile.com/index.html#changelog\nxpi形式のファイルがダウンロードされるので，適当なフォルダに保存する（自分はProgram FilesのZoteroのフォルダにAddonというフォルダを作って入れている）．\n\nZoteroを起動し，「ツール」&gt;「アドオン」をクリックすると現在インストールされているアドオンのリストが表示されるので，右上の歯車アイコンで「Install Add-on from File…」をクリック\n\n先ほど保存したxpi形式のファイルを選択．Zoteroを再起動しろと言われるので，Restart nowをクリック\n\nこれでインストールは完了．\n\npdfの保存先を設定する\ngoogle scholarやjstageなどから，ブラウザコネクタを使って文献を落としてきたときに，pdfファイルを保存するフォルダを任意に設定できる．自分はOnedrive内のフォルダを指定することでiPadなどから文献にアクセスできるようにしている．\n\n「ツール」&gt;「ZotFile Preferences…」&gt;「General Settings」&gt;「Location Files」と進む\n\nCustom Locationの横のChoose…を選択し，pdfを保存したいディレクトリを選択する\n\nUse subfolder defined byにチェックを入れ，横に「/%c」と入力する\n\n最後の行はフォルダ内にサブフォルダを作るかどうかで，「/%c」はZoteroのコレクションに対応する形でサブフォルダを作る設定．もちろん著者（「/%a」）や年度（「/%y」）でサブフォルダを作ることもできる．\n\n\npdfファイルの名前を設定する\n同じくブラウザコネクタ経由で文献を落としてきたときに，pdfファイルの命名規則を定めることができる．\n\n「ツール」&gt;「ZotFile Preferences…」&gt;「Renaming Rules」&gt;「Renaming Format」と進む\n\nUse Zotero to Renameのチェックを外す\n\nFormat for all Item Types except Patentのところに「{%a_}{%y_}{%t}」と入力する\n\n最後のところが命名規則で，「著者_年度_タイトル」という名前がpdfファイルにつくことになる．ここも先ほどと同じで任意に規則を作ることができる．\n命名規則を設定してから，文献を右クリックして「Manage Attachments」&gt;「Rename Attachments」とすると，pdfファイルがリネームされる．\n\n\n\nBetter BibTeXの導入\n導入の流れは先ほどと同じ． ダウンロード元はGithubのreleaseから． https://github.com/retorquere/zotero-better-bibtex/releases\n\nCite Keyの自動生成\nBibtexで引用する際に使用するCitekeyをいい感じで自動生成してくれる．\n\n「編集」&gt; 「設定」&gt;「Better BibTeX」&gt;「Citation keys」とすすむ\n「Citation key format」のところに「[Auth]-[year]」と入力\nとなりの「Export」に移って，「Fields to omit from export」のところに「abstract, doi, file」と入力\n「Advanced」に移って，「Ideographs in citekeys」の「Apply kuroshiro romajization in Japanese names/titles」のところにチェックをいれる\n\n2のところがCitation keyの命名規則で，「著者-年」という形で生成される．もちろんTitleなどを組み合わせてカスタマイズできる． 3はBibtexファイルの出力時にabstractやdoiを出力しないという設定（ファイルが長くなって邪魔くさいので…）． 4は著者名に日本語が含まれている場合に読みを抽出してローマ字化し，Citation keyに利用するという設定．完全に正確ではないが，今のところは不自由なく使えていると思う．"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#j-stageのtranslatorの修正",
    "href": "blog/posts/Zoteroの設定備忘録.html#j-stageのtranslatorの修正",
    "title": "Zoteroの設定備忘録",
    "section": "J-StageのTranslatorの修正",
    "text": "J-StageのTranslatorの修正\n社会学だと主要な邦ジャーナルはjstageからダウンロードすることになるが，そのままだと著者名とタイトルがうまく取れないという問題がある．\n\n著者名：姓と名が反対でとれてしまう．これが連鎖的にpdfのファイル名にまで影響してくる\nタイトル：サブタイトルがとれない．このままだと手動入力することになる．\n\nこれを，JstageのTranslatorを修正することで対応する．\nZoteroのデータフォルダ（Windowsの場合Users）内のTranslatorsの中にある「J-Stage.js」を開く．\n87行目あたりから以下のように修正する．\n// get RIS Link\n    //var bibtexurl = ZU.xpathText(doc, '//a[contains(text(), \"BIB TEX\")]/@href'); // コメントアウト\n    var risurl = ZU.xpathText(doc, '//a[contains(text(), \"RIS\")]/@href'); // 追加\n    // ZU.doGet(bibtexurl, function (text) { // コメントアウト\n    ZU.doGet(risurl, function (text) { //追加\n        // var bibtex = text; // コメントアウト\n        if (text.match(/TI  - .+?\\nTI  -  \\n/)) { // 追加\n            var bibtex = text.replace(\"TI  - \",\"TIT  - \").replace(\"\\nTI  -  \\n\",\"\\n\").replace(\"TIT  - \",\"TI  - \"); // 追加\n        } else { // 追加\n            var bibtex = text.replace(\"TI  - \",\"TIT  - \").replace(\"\\nTI  - \",\"――\").replace(\"TIT  - \",\"TI  - \"); // 追加\n        } // 追加\n        // Zotero.debug(bibtex)\n        var translator = Zotero.loadTranslator(\"import\");\n        // translator.setTranslator(\"9cb70025-a888-4a29-a210-93ec52da40d4\"); // コメントアウト\n        translator.setTranslator(\"32d59d2d-b65a-4da4-b0a3-bdd3cfb979e7\");  // 追加\n何をしているかを簡単に解説すると，まずjstageから情報を取ってくるときのソースをBibtexからRISに変更している．こうすることでBibtexに適用される日本人著者のオリジナルルールを回避する．\nまたjstageが提供するRISファイルの中身を見るとタイトルを保存するフィールド（TI）が二つ用意されていることがわかるので，二つとも埋まっている（サブタイトルがある）ときはそれを「――」でつないで結合している（7～11行目）"
  },
  {
    "objectID": "blog/posts/Zoteroの設定備忘録.html#社会学評論のcslファイル",
    "href": "blog/posts/Zoteroの設定備忘録.html#社会学評論のcslファイル",
    "title": "Zoteroの設定備忘録",
    "section": "社会学評論のcslファイル",
    "text": "社会学評論のcslファイル\n社会学でよく使われる社会学評論スタイル準拠のCSLファイルを作ってみた． 現状，英語と日本語は別ファイルで，学術論文と本の章は対応している．（2021-08-29）\nhttps://github.com/Kentaro-Kamada/hyoron-style\n\njstage周りの設定について\n\nhttps://home.hirosaki-u.ac.jp/yaneura/353/\nhttps://forums.zotero.org/discussion/5376/j-stage-translator-updated"
  },
  {
    "objectID": "blog/posts/学生生活実態調査の文字コード.html",
    "href": "blog/posts/学生生活実態調査の文字コード.html",
    "title": "学生生活実態調査の文字コード",
    "section": "",
    "text": "文字コードがカオスで調べるのが大変だったのでメモ\n\n\n\n\n\n\n\n\n\n年次\n当該データ\n文字コード\nURL\n\n\n\n\n1991\n0078.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0078\n\n\n1992\n0079.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0079\n\n\n1993\n0053.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0053\n\n\n1994\n0080.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0080\n\n\n1995\n0125.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0125\n\n\n1996\n0126.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0126\n\n\n1997\n0127.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0127\n\n\n1998\n0128.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0128\n\n\n1999\n0157.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0157\n\n\n2000\n0201.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0201\n\n\n2001\n0267.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0267\n\n\n2002\n0292.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0292\n\n\n2003\n0345.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0345\n\n\n2004\n0399.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0399\n\n\n2005\n0519.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0519\n\n\n2006\n0562.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0562\n\n\n2007\n0605.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0605\n\n\n2008\n0664.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0664\n\n\n2009\n0753.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0753\n\n\n2010\n0812.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0812\n\n\n2011\n0841.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0841\n\n\n2012\n0879.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0879\n\n\n2013\n0955.sav\nutf8\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=0955\n\n\n2014\n1057.sav\nutf8\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1057\n\n\n2015\n1099.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1099\n\n\n2016\n1163.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1163\n\n\n2017\n1232.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1232\n\n\n2018\n1295.sav\nutf8\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1295\n\n\n2019\n1384.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1384\n\n\n2020\n1442.sav\ncp932\nhttps://ssjda.iss.u-tokyo.ac.jp/Direct/gaiyo.php?eid=1442"
  },
  {
    "objectID": "blog/posts/複利計算.html",
    "href": "blog/posts/複利計算.html",
    "title": "複利計算",
    "section": "",
    "text": "library(tidyverse)"
  },
  {
    "objectID": "blog/posts/複利計算.html#複利計算",
    "href": "blog/posts/複利計算.html#複利計算",
    "title": "複利計算",
    "section": "複利計算",
    "text": "複利計算\n\n年間\\(a\\)万円ずつ積み立てることを考える\n年利は\\(r\\)とする\n\n\\[\\begin{align*}\n& 1年目:ar^1 \\\\\n& 2年目:ar^1 + ar^2 \\\\\n& 3年目:ar^1 + ar^2 + ar^3 \\\\\n& n年目:\\sum_{i=1}^{n} ar^i = \\frac{ar(1 - r^n)}{1 - r}\n\\end{align*}\\]\n\n等比級数の和の導出\n\n\\[\\begin{align*}\nS =& ar + ar^2 + ar^3 + ... + ar^n \\\\\nrS =& \\qquad\\; ar^2 + ar^3 + ... + ar^n + ar^{n+1} \\\\\nS - rS =& ar - ar^{n+1} \\\\\nS(1 - r) =& ar(1 - r^n) \\\\\nS =& \\frac{ar(1 - r^n)}{1 - r}\n\\end{align*}\\]\n\nシミュレーション\n\n\\(n\\)：30年積み立てる\n\\(a\\)：年間40万円ずつ（月あたり3.3333万円）\n\\(r\\)：年利は5％と仮定\n\n\n\nn &lt;- 30\na &lt;- 40\nr &lt;- 1.05\n\ntibble(\n  year = 1:n,\n  cost = a*year,\n  gain = a*r^year,\n  return = a*r*(1 - r^year)/(1 - r),\n) |&gt; \n  ggplot()+\n  geom_line(aes(x = year, y = return), color = 'red')+\n  geom_col(aes(x = year, y = cost), alpha = .7)+\n  geom_line(aes(x = year, y = cost), color = 'blue')"
  },
  {
    "objectID": "blog/posts/複利計算.html#利率が年度ごとに変動する場合",
    "href": "blog/posts/複利計算.html#利率が年度ごとに変動する場合",
    "title": "複利計算",
    "section": "利率が年度ごとに変動する場合",
    "text": "利率が年度ごとに変動する場合\n\n年利は確率的に変動する値\n\n定数（\\(r\\)）ではなく、変数（\\(r_i\\)）として考える\n\n\n\\[\\begin{align*}\n& 1年目:ar_1 \\\\\n& 2年目:ar_1 + ar_1r_2\\\\\n& 3年目:ar_1 + ar_1r_2 + ar_1r_2r_3 = a(r_1 + r_1r_2 + r_1r_2r_3)\\\\\n& n年目:ar_1 + ar_1r_2 + ar_1r_2r_3 + ... + ar_1r_2r_3...r_n = a\\sum_{i=1}^{n} \\prod_{i=1}^{n}r_i\n\\end{align*}\\]\nここで、\\(r_i \\sim \\mathrm{Normal}(1.05, 0.1)\\)とする\n\ntibble(\n  year = 1:n,\n  rate = rnorm(n, r, .1),\n  cost = a*year,\n  return = a*(accumulate(rate, \\(x, y) x*y) |&gt; accumulate(\\(x, y) x + y)),\n) |&gt; \n  ggplot()+\n  geom_line(aes(x = year, y = return), color = 'red')+\n  geom_col(aes(x = year, y = cost), alpha = .7)+\n  geom_line(aes(x = year, y = cost), color = 'blue')"
  },
  {
    "objectID": "blog/posts/複利計算.html#利率がランダムウォークする場合",
    "href": "blog/posts/複利計算.html#利率がランダムウォークする場合",
    "title": "複利計算",
    "section": "利率がランダムウォークする場合",
    "text": "利率がランダムウォークする場合\n\n景気は各時点でランダムに発生するわけではない\nむしろ1時点前の状況を強く反映する\n年利がランダムウォークすると仮定する\n\n\\[\\begin{align*}\n& r_1 \\sim \\mathrm{Normal}(1.05, 0.1) \\\\\n& r_{i + 1} = r_i + e_i, \\; e_i \\sim \\mathrm{Normal}(0, 0.01)\n\\end{align*}\\]\nパラメータの設定が難しい…\n\ntibble(\n  year = 1:n,\n  error = rnorm(n, 0, 0.01),\n  rate = accumulate(error, \\(x, y) x + y, .init = rnorm(1, r, .1))[-n],\n  cost = a*year,\n  return = a*(accumulate(rate, \\(x, y) x*y) |&gt; accumulate(\\(x, y) x + y)),\n) |&gt; \n  ggplot()+\n  geom_line(aes(x = year, y = return), color = 'red')+\n  geom_col(aes(x = year, y = cost), alpha = .7)+\n  geom_line(aes(x = year, y = cost), color = 'blue')"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html",
    "href": "blog/posts/Rでロジットモデル.html",
    "title": "Rでロジットモデル",
    "section": "",
    "text": "これは簡単で，2値のfactorを従属変数，リンク関数をglm(family = binomial('logit'))のように指定してやればOK\nちなみにbinomial('probit')にしてやればプロビット回帰になる"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html#二項ロジット",
    "href": "blog/posts/Rでロジットモデル.html#二項ロジット",
    "title": "Rでロジットモデル",
    "section": "",
    "text": "これは簡単で，2値のfactorを従属変数，リンク関数をglm(family = binomial('logit'))のように指定してやればOK\nちなみにbinomial('probit')にしてやればプロビット回帰になる"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html#多項ロジット",
    "href": "blog/posts/Rでロジットモデル.html#多項ロジット",
    "title": "Rでロジットモデル",
    "section": "多項ロジット",
    "text": "多項ロジット\nnnet::multinomは検定とかやってくれないし，かといってmlogit::mlogitは独自のデータ形式を要求してくるので面倒くさい．ただ，nnetはbroomに対応しているので，検定部分はbroomに任せることでこの問題は解決．\nということでこれからはnnetで推定→broomに放り込んで検定というのを使っていきたい"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html#順序ロジット",
    "href": "blog/posts/Rでロジットモデル.html#順序ロジット",
    "title": "Rでロジットモデル",
    "section": "順序ロジット",
    "text": "順序ロジット\nMASS::polrが最有力か？ただし，data.frame形式しか受け付けていないのでtibbleのままデータを入れるとエラーになるのが難点．以前LMestで潜在移行モデルを動かした時にも似たようなことがあった．なんとかならんものか…\nちなみにpolrってなんだろうと思ったら，proportional odds logistic regression（比例オッズロジスティック回帰）の略でした．"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html#一般化順序ロジット",
    "href": "blog/posts/Rでロジットモデル.html#一般化順序ロジット",
    "title": "Rでロジットモデル",
    "section": "一般化順序ロジット",
    "text": "一般化順序ロジット\n平行性の仮定を一部緩めた部分比例オッズモデル（partial proportional odds model）1とかをやりたいときは，VGAM::vglmが使える．\nx1，x2，x3のうち，x1だけ平行性の仮定を緩めたいときは，以下のように書く\nVGAM::vglm(formula = y ~ x1 + x2 + x3, \n           family = VGAM::cumulative(parallel = FALSE ~ 1 + x1, reverse = TRUE),\n           data = data) \nparallelの書き方がミソで，parallel = FALSEのあとに等値制約を緩めたいパラメタをformulaで記述する．今回の場合は切片（閾値）とx1の係数だけは各段階で異なるので~ 1 + x1と記述する．また，parallel = TRUEとすると通常の順序ロジットモデルになる．\nreverseは係数の符号を反転させるオプションで，reverse = TRUEを入れるとStataのgologit2を用いた時の結果と同じになる．"
  },
  {
    "objectID": "blog/posts/Rでロジットモデル.html#footnotes",
    "href": "blog/posts/Rでロジットモデル.html#footnotes",
    "title": "Rでロジットモデル",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n教育社会学での使用例は近藤・古田（2009）とか．↩︎"
  },
  {
    "objectID": "blog/posts/rlang学習.html",
    "href": "blog/posts/rlang学習.html",
    "title": "rlang学習",
    "section": "",
    "text": "Advanced R"
  },
  {
    "objectID": "blog/posts/rlang学習.html#参考",
    "href": "blog/posts/rlang学習.html#参考",
    "title": "rlang学習",
    "section": "",
    "text": "Advanced R"
  },
  {
    "objectID": "blog/posts/rlang学習.html#下準備",
    "href": "blog/posts/rlang学習.html#下準備",
    "title": "rlang学習",
    "section": "下準備",
    "text": "下準備\n\nlibrary(rlang)\nlibrary(lobstr)"
  },
  {
    "objectID": "blog/posts/rlang学習.html#expression",
    "href": "blog/posts/rlang学習.html#expression",
    "title": "rlang学習",
    "section": "expression",
    "text": "expression\n\nexpr：コードをそのまま捕まえる\n\n作成されたオブジェクト：expression\ncall, symbol, constant, pairlistの4つからなる\n\n\n\nexpr(mean(x, na.rm = TRUE))\n\nmean(x, na.rm = TRUE)\n\nexpr(10 + 100 + 1000)\n\n10 + 100 + 1000\n\n\n\nexprは関数の引数なども書いてあるまま保持する\n\n\n# これはxになる\ncapture_it &lt;- function(x) {\n  expr(x)\n}\n\ncapture_it(a + b + c)\n\nx\n\n\n\n引数は評価した上でコードを保持したい場合はenexprを使う\n\n\ncapture_it &lt;- function(x) {\n  enexpr(x)\n}\ncapture_it(a + b + c)\n\na + b + c"
  },
  {
    "objectID": "blog/posts/rlang学習.html#abstract-syntax-tree-ast-による表現",
    "href": "blog/posts/rlang学習.html#abstract-syntax-tree-ast-による表現",
    "title": "rlang学習",
    "section": "abstract syntax tree (AST) による表現",
    "text": "abstract syntax tree (AST) による表現\n\ncodeはtree形式で表現できる\nfがcall, aがsymbol, “b”がconstantらしい\n\n\nlobstr::ast(f(a, \"b\"))\n\n█─f \n├─a \n└─\"b\" \n\n\n\n+や*も関数であることがわかる\n\n\nlobstr::ast(1 + 2 * 3)\n\n█─`+` \n├─1 \n└─█─`*` \n  ├─2 \n  └─3"
  },
  {
    "objectID": "blog/posts/rlang学習.html#codeを生成するcode",
    "href": "blog/posts/rlang学習.html#codeを生成するcode",
    "title": "rlang学習",
    "section": "codeを生成するcode",
    "text": "codeを生成するcode\n\ncall2\n\n\ncall2('f', 1, 2)\n\nf(1, 2)\n\ncall2('+', 1, call2('*', 2, 3))\n\n1 + 2 * 3\n\n\n\n!!を使ったcodeの生成\n\n捕まえておいたコードを評価したいところで評価する\n\n\n\nxx &lt;- expr(x + x)\nyy &lt;- expr(y + y)\n\nexpr(!!xx / !!yy)\n\n(x + x)/(y + y)"
  },
  {
    "objectID": "blog/posts/rlang学習.html#codeの評価",
    "href": "blog/posts/rlang学習.html#codeの評価",
    "title": "rlang学習",
    "section": "codeの評価",
    "text": "codeの評価\n\neval(expr, env)：exprをenvで評価\n\n\neval(expr(x + y), env(x = 1, y = 10))\n\n[1] 11\n\neval(expr(x + y), env(x = 2, y = 100))\n\n[1] 102\n\n\n\nenvを指定しないときは現在のenvironmentで評価\n\n\nx &lt;- 10\ny &lt;- 100\n\neval(expr(x + y))\n\n[1] 110\n\n\n\nデータを環境として扱う\neval_tidy(expr, data)：exprをdata内部で評価\n\ndataでcurrent environmentを上書きするのでdata-mask呼ばれる\n\nevalでもできないことはないが、落とし穴があるらしい\n\n\ndf &lt;- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n\n[1]  4  6  4  6 10\n\n\n\ndplyrっぽい関数\n\n\nwith2 &lt;- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n\n[1]  4  6  4  6 10"
  },
  {
    "objectID": "blog/posts/rlang学習.html#quosure",
    "href": "blog/posts/rlang学習.html#quosure",
    "title": "rlang学習",
    "section": "Quosure",
    "text": "Quosure\n\nexprだけを使う方法は問題がでてくる\n関数の内部でaを定義してみる\n\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enexpr(expr), df)\n}\n\n\nさらに関数の外部（global environment）でもaを定義する\n\n\ndf &lt;- data.frame(x = 1:3)\na &lt;- 10\n\n\nこの状態でwith2を使うと問題が発生\n\nglobal environmentのaではなく、関数内部で定義したaが優先的に使われる\n\n\n\nwith2(df, x + a)\n\n[1] 1001 1002 1003\n\n\n\nquosure：expressionとenvironmentをセットで保持する\n\ndata-maskでは、eval_tidyのdata -&gt; quosureのenv -&gt; global envの順で評価される\n\n\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enquo(expr), df)\n}\n\nx &lt;- 10\n\nwith2(df, x + a)\n\n[1] 11 12 13"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html",
    "title": "PIAAC、PISAの標準誤差",
    "section": "",
    "text": "library(tidyverse)\nlibrary(haven)\nlibrary(survey)\nlibrary(srvyr)\nlibrary(kamaken)\n\nkable &lt;- partial(knitr::kable, digits = 3)\n\n\n\n\n\nPIAAC 1st cycleの日本データ（SPSS形式）\n\nhttps://webfs.oecd.org/piaac/puf-data/SPSS/prgjpnp1.sav\n\n変数の名前を適宜変更しておく\n\n\ndata &lt;- read_sav('data/prgjpnp1.sav')\n# 直接読み込むこともできるが多少時間がかかる\n# data &lt;- read_sav('https://webfs.oecd.org/piaac/puf-data/SPSS/prgjpnp1.sav')\n\ndf &lt;- \n  data |&gt; \n  # 変数を絞る\n  select(\n    country = CNTRYID, \n    id = SEQID,\n    age = AGE_R, \n    gender = GENDER_R, \n    region = REG_TL2, \n    edu = B_Q01a, \n    medu = J_Q06b, \n    fedu = J_Q07b, \n    numbooks = J_Q08,\n    sampling_weight = SPFWT0, \n    # 読解力、数的思考力、ITスキルのスコア\n    matches('^PV'), \n    # Replicate weights\n    matches(str_c('SPFWT', 1:80)),\n    VEMETHOD\n  ) |&gt; \n  # 変数名を小文字に変換\n  rename_with(str_to_lower) |&gt; \n  as_factor() |&gt; \n  mutate(\n    age = as.character(age) |&gt; parse_double(),\n    # 年齢をカテゴリ化\n    agegroup = cut(\n      age,\n      breaks = c(15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65),\n      labels = c('16-20', '21-25', '26-30', '31-35', '36-40', '41-45', '46-50', '51-55', '56-60', '61-65')\n    ),\n    # 大学卒業ダミー\n    univ = case_match(\n      edu,\n      'No formal qualification or below ISCED 1' ~ 0,\n      'ISCED 2' ~ 0,\n      'ISCED 3C shorter than 2 years' ~ 0,\n      'ISCED 3C 2 years or more' ~ 0,\n      'ISCED 3A-B' ~ 0,\n      'ISCED 3 (without distinction A-B-C, 2y+)' ~ 0,\n      'ISCED 4 (without distinction A-B-C)' ~ 0,\n      'ISCED 5B' ~ 0,\n      'ISCED 5A, bachelor degree' ~ 1,\n      'ISCED 5A, master degree' ~ 1,\n      'ISCED 6' ~ 1,\n      'Foreign qualification' ~ NA,\n      NA ~ NA\n    )\n  )"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html#前準備",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html#前準備",
    "title": "PIAAC、PISAの標準誤差",
    "section": "",
    "text": "library(tidyverse)\nlibrary(haven)\nlibrary(survey)\nlibrary(srvyr)\nlibrary(kamaken)\n\nkable &lt;- partial(knitr::kable, digits = 3)\n\n\n\n\n\nPIAAC 1st cycleの日本データ（SPSS形式）\n\nhttps://webfs.oecd.org/piaac/puf-data/SPSS/prgjpnp1.sav\n\n変数の名前を適宜変更しておく\n\n\ndata &lt;- read_sav('data/prgjpnp1.sav')\n# 直接読み込むこともできるが多少時間がかかる\n# data &lt;- read_sav('https://webfs.oecd.org/piaac/puf-data/SPSS/prgjpnp1.sav')\n\ndf &lt;- \n  data |&gt; \n  # 変数を絞る\n  select(\n    country = CNTRYID, \n    id = SEQID,\n    age = AGE_R, \n    gender = GENDER_R, \n    region = REG_TL2, \n    edu = B_Q01a, \n    medu = J_Q06b, \n    fedu = J_Q07b, \n    numbooks = J_Q08,\n    sampling_weight = SPFWT0, \n    # 読解力、数的思考力、ITスキルのスコア\n    matches('^PV'), \n    # Replicate weights\n    matches(str_c('SPFWT', 1:80)),\n    VEMETHOD\n  ) |&gt; \n  # 変数名を小文字に変換\n  rename_with(str_to_lower) |&gt; \n  as_factor() |&gt; \n  mutate(\n    age = as.character(age) |&gt; parse_double(),\n    # 年齢をカテゴリ化\n    agegroup = cut(\n      age,\n      breaks = c(15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65),\n      labels = c('16-20', '21-25', '26-30', '31-35', '36-40', '41-45', '46-50', '51-55', '56-60', '61-65')\n    ),\n    # 大学卒業ダミー\n    univ = case_match(\n      edu,\n      'No formal qualification or below ISCED 1' ~ 0,\n      'ISCED 2' ~ 0,\n      'ISCED 3C shorter than 2 years' ~ 0,\n      'ISCED 3C 2 years or more' ~ 0,\n      'ISCED 3A-B' ~ 0,\n      'ISCED 3 (without distinction A-B-C, 2y+)' ~ 0,\n      'ISCED 4 (without distinction A-B-C)' ~ 0,\n      'ISCED 5B' ~ 0,\n      'ISCED 5A, bachelor degree' ~ 1,\n      'ISCED 5A, master degree' ~ 1,\n      'ISCED 6' ~ 1,\n      'Foreign qualification' ~ NA,\n      NA ~ NA\n    )\n  )"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html#標準誤差の推定式",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html#標準誤差の推定式",
    "title": "PIAAC、PISAの標準誤差",
    "section": "標準誤差の推定式",
    "text": "標準誤差の推定式\n\njackknife法による標準誤差\n\n\\[\n\\mathrm{SE}_\\theta = \\sqrt{h\\sum_{r=1}^{R} (\\hat{\\theta}_{(r)} - \\hat{\\theta})^2}\n\\]\n\n\\(R\\)：反復回数、replicate weightの数（PIAACは80）\n\\(\\hat{\\theta}_{(r)}\\)：\\(r\\)番目のreplicate weightを用いた推定値\n\\(\\hat{\\theta}\\)：全体の推定値（サンプリングウェイトを用いた推定値）\n\\(h\\)：乗数、 Jackknife法のバリエーションによって異なる\n\nJK1の場合は\\(h = \\frac{R-1}{R}\\)\nJK2の場合は\\(h = 1\\)"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html#分析",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html#分析",
    "title": "PIAAC、PISAの標準誤差",
    "section": "分析",
    "text": "分析\n\n点推定値\njackknife法による標準誤差\n\nの二つを推定する\n\npackageによる推定\n\nsurveyパッケージ（のラッパーのsrvyrパッケージ）を用いる\ntype: 標準誤差の推定方法\n\nPIAACではJK1の国とJK2の国が混在（変数VEMETHODにどちらを使用すれば良いかが書かれている）\n日本はJK2で推定する\n\n\n\ndf_design &lt;- \n  df |&gt; \n  # 調査デザインの設定\n  as_survey_rep(\n    weights = sampling_weight, \n    repweights = matches('spfwt'), \n    type = 'JK2',\n    mse = TRUE\n  )\n\nresult_literacy &lt;- \n  df_design |&gt; \n  # 読解力の各PVごとに平均値と標準誤差を計算\n  summarise(\n    across(matches('pvlit'), \\(x) survey_mean(x, na.rm = TRUE))\n  ) \n  \n# 結果の整理\npackage &lt;- \n  result_literacy |&gt;\n  rename_with(\\(x) str_replace(x, '(\\\\d)$', '\\\\1_estimate')) |&gt;\n  # 縦持ちに変換\n  pivot_longer(\n    cols = matches('pvlit'),\n    names_to = c('literacy', '.value'),\n    names_pattern = '(pvlit\\\\d{1,2})_(.+)',\n  ) \n\nkable(package)\n\n\n\n\nliteracy\nestimate\nse\n\n\n\n\npvlit1\n296.468\n0.549\n\n\npvlit2\n296.143\n0.529\n\n\npvlit3\n296.184\n0.543\n\n\npvlit4\n296.111\n0.541\n\n\npvlit5\n296.172\n0.522\n\n\npvlit6\n296.936\n0.543\n\n\npvlit7\n295.561\n0.481\n\n\npvlit8\n296.827\n0.518\n\n\npvlit9\n296.188\n0.521\n\n\npvlit10\n295.832\n0.542\n\n\n\n\n\n\n\n手作業による推定\n\npoint_estimate &lt;-\n  df |&gt; \n  select(sampling_weight, matches('(pvlit|spfwt)')) |&gt; \n  summarise(\n    across(\n      matches('pvlit'), \n      \\(x) weighted.mean(x, w = sampling_weight, na.rm = TRUE), \n      .names = '{.col}_estimate'\n    )\n  ) |&gt; \n  pivot_longer(\n    cols = matches('pvlit'),\n    names_to = c('literacy', '.value'),\n    names_pattern = '(pvlit\\\\d{1,2})_(.+)',\n  )\n  \n# jackknife法に用いるウェイト（80個）\njackweight &lt;- select(df, matches('spfwt'))\n\njack_estimate &lt;-\n  # 各ウェイトを用いて、それぞれのPVの平均値を計算\n  map(\n    jackweight, \\(weight) \n    df |&gt; \n      summarise(\n        across(\n          matches('pvlit'),\n          \\(x) weighted.mean(x, w = weight, na.rm = TRUE),\n          .names = '{.col}_jack'\n        )\n      )\n  ) |&gt; \n  bind_rows(.id = 'replicate') |&gt; \n  pivot_longer(\n    cols = matches('pvlit'),\n    names_to = c('literacy', '.value'),\n    names_pattern = '(pvlit\\\\d{1,2})_(.+)',\n  )\n\nhandmade &lt;- \n  # 点推定値にジャックナイフウェイトを用いた推定値を結合\n  left_join(\n    point_estimate, \n    jack_estimate, \n    by = join_by(literacy)\n  ) |&gt; \n  # 標準誤差の計算\n  summarise(\n    estimate = mean(estimate),\n    se = sqrt(sum((estimate - jack)^2)),\n    .by = literacy\n  )\n\nkable(handmade)\n\n\n\n\nliteracy\nestimate\nse\n\n\n\n\npvlit1\n296.468\n0.549\n\n\npvlit2\n296.143\n0.529\n\n\npvlit3\n296.184\n0.543\n\n\npvlit4\n296.111\n0.541\n\n\npvlit5\n296.172\n0.522\n\n\npvlit6\n296.936\n0.543\n\n\npvlit7\n295.561\n0.481\n\n\npvlit8\n296.827\n0.518\n\n\npvlit9\n296.188\n0.521\n\n\npvlit10\n295.832\n0.542\n\n\n\n\n\n\n\n結果の比較\n\n結果は一致する\n\n\nleft_join(\n  package, \n  handmade, \n  by = join_by(literacy),\n  suffix = c('_package', '_handmade')\n) |&gt; \n  select(literacy, estimate_package, estimate_handmade, se_package, se_handmade) |&gt;\n  mutate(\n    diff_estimate = estimate_package - estimate_handmade,\n    diff_se = se_package - se_handmade\n  ) |&gt; \n  kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nliteracy\nestimate_package\nestimate_handmade\nse_package\nse_handmade\ndiff_estimate\ndiff_se\n\n\n\n\npvlit1\n296.468\n296.468\n0.549\n0.549\n0\n0\n\n\npvlit2\n296.143\n296.143\n0.529\n0.529\n0\n0\n\n\npvlit3\n296.184\n296.184\n0.543\n0.543\n0\n0\n\n\npvlit4\n296.111\n296.111\n0.541\n0.541\n0\n0\n\n\npvlit5\n296.172\n296.172\n0.522\n0.522\n0\n0\n\n\npvlit6\n296.936\n296.936\n0.543\n0.543\n0\n0\n\n\npvlit7\n295.561\n295.561\n0.481\n0.481\n0\n0\n\n\npvlit8\n296.827\n296.827\n0.518\n0.518\n0\n0\n\n\npvlit9\n296.188\n296.188\n0.521\n0.521\n0\n0\n\n\npvlit10\n295.832\n295.832\n0.542\n0.542\n0\n0\n\n\n\n\n\n\n\nPVの統合\n\n読解力、数的思考力などは複数のPV（Plausible Values）という形で測定\nPVを用いた分析の結果は、多重代入法の要領で統合が可能\n詳しくは van Buuren (2018) などを参照\n平均値\n\n\\[\n\\hat{\\theta} = \\frac{1}{M} \\sum_{m=1}^{M} \\hat{\\theta}_{(m)}\n\\]\n\n各PVにおいて生じる分散の平均（分散の平均値）\n\n\\[\n\\bar{U} = \\frac{1}{M} \\sum_{m=1}^{M} \\hat{U}_{(m)}\n\\]\n\nPV間で生じる分散（平均値の分散）\n\n\\[\nB = \\frac{1}{M-1} \\sum_{m=1}^{M} (\\hat{\\theta}_{(m)} - \\hat{\\theta})^2\n\\]\n\n統合された推定値の標準誤差\n\n\\[\n\\hat{SE} = \\sqrt{\\bar{U} + \\left(1 + \\frac{1}{M}\\right)B}\n\\]\n\npool_rubin &lt;- function(.tibble, term = NULL) {\n  .tibble |&gt; \n    mutate(variance = std.error^2) |&gt;\n    summarise(\n      M = n(),\n      estimate.combined = mean(estimate),\n      Vw = sum(variance) / M,\n      Vb = sum((estimate - mean(estimate)) ^ 2) / (M - 1),\n      Vt = Vw + (1 + 1 / M) * Vb,\n      SE.combined = sqrt(Vt), \n      .by = {{term}}\n    ) |&gt; \n    # 信頼区間計算\n    mutate(\n      conf.low = estimate.combined - qnorm(1 - .025)*SE.combined,\n      conf.high = estimate.combined + qnorm(1 - .025)*SE.combined\n    ) |&gt; \n    select({{term}}, M, estimate = estimate.combined, std.error = SE.combined, conf.low, conf.high)\n} \n\n\n結果の統合\n\n\nhandmade |&gt; \n  rename(std.error = se) |&gt; \n  pool_rubin() |&gt; \n  kable()\n\n\n\n\nM\nestimate\nstd.error\nconf.low\nconf.high\n\n\n\n\n10\n296.242\n0.685\n294.9\n297.585"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html#より複雑なケース",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html#より複雑なケース",
    "title": "PIAAC、PISAの標準誤差",
    "section": "より複雑なケース",
    "text": "より複雑なケース\n\n因果効果の推定\n\n高等教育進学が読解力に与える因果効果の推定\nG-computation(Hernán and Robins 2020; Robins 1986)によるATEの推定\n関数定義\n\n.outcome：アウトカム変数\n.treatment：0-1の二値変数\n.formula_rhs：回帰式の右辺を指定\n\n~ treatment + covariate1 + covariate2 + ...のような形\n固定効果も指定可能：~ 1 | treatment + fixed_effect1 + fixed_effect2 + ...\nfixestパッケージでのformulaに準拠\n\n.estimand：推定対象\n\ncfmean：\\(\\mathrm{E}[Y^1]\\)と\\(\\mathrm{E}[Y^0]\\)\nATE：平均処置効果\n\n.weights：サンプリングウェイト\n.repweights：ジャックナイフ法に用いるreplicate weights\n.type：ジャックナイフ法のタイプ\n.by：効果の異質性を見たい変数を指定（NULLなら集団全体）\n\n\n\n# ATEをjackknife推定する関数\npiaac_ATE_jack &lt;- \n  function(.data, .outcome, .treatment, .formula_rhs, .estimand = c('cfmean', 'ATE'), .weights, .repweights, .type = c('JK1', 'JK2'), .by = NULL) {\n  .treatment &lt;- enquo(.treatment)\n  .weights &lt;- enquo(.weights)\n  .repweights &lt;- select(.data, {{.repweights}}) |&gt; names()\n  .by &lt;- enquo(.by)\n  # scale parameterの設定\n  scale &lt;- case_when(\n    .type == 'JK1' ~ (length(.repweights) - 1) / length(.repweights), \n    .type == 'JK2' ~ 1\n  )\n  # formulaの左辺に.outcomeを追加\n  .formula &lt;- rlang::`f_lhs&lt;-`(.formula_rhs, ensym(.outcome))\n  \n  # OLS推定\n  fit &lt;-\n    fixest::feols(\n      .formula,\n      data = .data,\n      combine.quick = FALSE,\n      weights = str_c('~', rlang::as_name(.weights)) |&gt; as.formula()\n    )\n  # 点推定値\n  res_point_estimate &lt;-\n    bind_rows(\n      broom::augment(fit, newdata = .data |&gt; mutate(!!.treatment := 0)),\n      broom::augment(fit, newdata = .data |&gt; mutate(!!.treatment := 1)),\n    ) |&gt;\n    group_by(pick(!!.treatment, !!.by)) |&gt;\n    summarise(\n      estimate = weighted.mean(.fitted, !!.weights),\n      .groups = 'drop'\n    ) |&gt; \n    mutate(estimand = 'cfmean')\n  if (.estimand == 'ATE') {\n    res_point_estimate &lt;-\n      res_point_estimate |&gt;\n      mutate(estimand = 'ATE') |&gt; \n      pivot_wider(names_from = !!.treatment, values_from = estimate) |&gt;\n      mutate(estimate = `1` - `0`) |&gt;\n      select(!c(`0`, `1`))\n  }\n\n  # 各replicate weightを使ってOLS推定し、jackknifeサンプルにおける点推定値を計算する\n  fit_jack &lt;-\n    furrr::future_map(\n      .repweights, .progress = TRUE, .options = furrr::furrr_options(seed = TRUE), \\(w) {\n        gc()\n        # weightが0のデータを削除\n        df_jack &lt;- .data |&gt; filter(!!ensym(w) != 0)\n        # OLSで推定\n        fit &lt;-\n          fixest::feols(\n            .formula,\n            data = df_jack,\n            weights = str_c('~', w) |&gt; as.formula(),\n            combine.quick = FALSE\n          )\n        # Y^1とY^0を計算\n        res_point_estimate_jack &lt;-\n          bind_rows(\n            broom::augment(fit, newdata = df_jack |&gt; mutate(!!.treatment := 0)),\n            broom::augment(fit, newdata = df_jack |&gt; mutate(!!.treatment := 1)),\n          ) |&gt;\n          group_by(pick(!!.treatment, !!.by)) |&gt;\n          summarise(\n            estimate = weighted.mean(.fitted, !!ensym(w)),\n            .groups = 'drop'\n          ) |&gt; \n          mutate(estimand = 'cfmean')\n        if (.estimand == 'ATE') {\n          res_point_estimate_jack &lt;-\n            res_point_estimate_jack |&gt;\n            mutate(estimand = 'ATE') |&gt;\n            pivot_wider(names_from = !!.treatment, values_from = estimate) |&gt;\n            mutate(estimate = `1` - `0`) |&gt;\n            select(!c(`0`, `1`))\n        }\n        res_point_estimate_jack\n      }\n    )\n  # 結果の統合\n  results &lt;-\n    fit_jack |&gt;\n    bind_rows(.id = 'no') |&gt;\n    rename(estimate_jack = estimate) |&gt;\n    # 点推定値をくっつける\n    left_join(res_point_estimate |&gt; rename(estimate_all = estimate))\n\n  # jackknife標準誤差の計算\n  if (.estimand == 'cfmean') {\n    results &lt;-\n      results |&gt;\n      group_by(pick(estimand, !!.treatment, !!.by)) |&gt;\n      summarise(\n        estimate = mean(estimate_all),\n        std.error = sqrt(scale * sum((estimate_all - estimate_jack)^2, na.rm = TRUE)),\n        .groups = 'drop'\n      )\n  }\n  else if (.estimand == 'ATE') {\n    results &lt;-\n      results |&gt;\n      group_by(pick(estimand, !!.by)) |&gt;\n      summarise(\n        estimate = mean(estimate_all),\n        std.error = sqrt(scale * sum((estimate_all - estimate_jack)^2, na.rm = TRUE)),\n        .groups = 'drop'\n      )\n  }\n  results\n}\n\n\n\n推定結果\n\n# 並列化\nfuture::plan('multisession')\n\ndf |&gt; \n  filter(age &gt;= 26) |&gt; \n  piaac_ATE_jack(\n    .outcome = pvlit1,\n    .treatment = univ,\n    .formula_rhs = ~ 1 | univ^gender^agegroup,\n    .estimand = 'ATE',\n    .weights = sampling_weight,\n    .repweights = matches('spfwt'),\n    .type = 'JK2',\n    .by = c(gender, agegroup)\n  ) |&gt; \n  kable()\n\n\n\n\nestimand\ngender\nagegroup\nestimate\nstd.error\n\n\n\n\nATE\nMale\n26-30\n26.590\n4.692\n\n\nATE\nMale\n31-35\n24.986\n4.766\n\n\nATE\nMale\n36-40\n28.109\n3.835\n\n\nATE\nMale\n41-45\n28.916\n3.917\n\n\nATE\nMale\n46-50\n30.594\n4.789\n\n\nATE\nMale\n51-55\n35.483\n5.616\n\n\nATE\nMale\n56-60\n38.366\n5.703\n\n\nATE\nMale\n61-65\n24.382\n4.711\n\n\nATE\nFemale\n26-30\n22.546\n3.546\n\n\nATE\nFemale\n31-35\n24.534\n3.581\n\n\nATE\nFemale\n36-40\n27.753\n4.466\n\n\nATE\nFemale\n41-45\n34.266\n4.167\n\n\nATE\nFemale\n46-50\n23.310\n4.708\n\n\nATE\nFemale\n51-55\n32.056\n5.081\n\n\nATE\nFemale\n56-60\n26.026\n4.619\n\n\nATE\nFemale\n61-65\n40.169\n10.041\n\n\n\n\n\n\n\n10個のPVに対して一括で推定\n\n# 読解力PVの変数名を取得\npvs &lt;- df |&gt; select(matches('pvlit')) |&gt; names()\n\nresult &lt;- \n  map(\n    pvs,\n    \\(x) piaac_ATE_jack(\n      .data = df |&gt; filter(age &gt;= 26),\n      # mapで回すときは`!!`を使う\n      .outcome = !!x,\n      .treatment = univ,\n      .formula_rhs = ~ 1 | univ^gender^agegroup,\n      .estimand = 'ATE',\n      .weights = sampling_weight,\n      .repweights = matches('spfwt'),\n      .type = 'JK2',\n      .by = gender\n    )) |&gt; \n  bind_rows(.id = 'pv')\n\nresult\n\n# A tibble: 20 × 5\n   pv    estimand gender estimate std.error\n   &lt;chr&gt; &lt;chr&gt;    &lt;fct&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 1     ATE      Male       29.4      1.61\n 2 1     ATE      Female     29.2      2.01\n 3 2     ATE      Male       29.8      1.78\n 4 2     ATE      Female     29.7      1.98\n 5 3     ATE      Male       29.4      1.76\n 6 3     ATE      Female     29.6      2.13\n 7 4     ATE      Male       32.2      1.73\n 8 4     ATE      Female     32.3      2.16\n 9 5     ATE      Male       30.6      1.71\n10 5     ATE      Female     29.8      1.82\n11 6     ATE      Male       30.5      1.67\n12 6     ATE      Female     29.7      2.06\n13 7     ATE      Male       30.4      1.78\n14 7     ATE      Female     31.0      1.80\n15 8     ATE      Male       30.0      1.84\n16 8     ATE      Female     31.2      1.91\n17 9     ATE      Male       32.1      1.66\n18 9     ATE      Female     31.3      2.17\n19 10    ATE      Male       30.8      1.60\n20 10    ATE      Female     32.7      1.81\n\n\n\n\n結果の統合\n\nresult |&gt; \n  pool_rubin(term = c(estimand, gender)) |&gt; \n  kable()\n\n\n\n\nestimand\ngender\nM\nestimate\nstd.error\nconf.low\nconf.high\n\n\n\n\nATE\nMale\n10\n30.526\n1.996\n26.613\n34.439\n\n\nATE\nFemale\n10\n30.643\n2.364\n26.011\n35.276"
  },
  {
    "objectID": "blog/posts/Standard_Errors_in_PIAAC.html#参考文献",
    "href": "blog/posts/Standard_Errors_in_PIAAC.html#参考文献",
    "title": "PIAAC、PISAの標準誤差",
    "section": "参考文献",
    "text": "参考文献\nJakubowski, Maciej & Artur Pokropek, 2019, “piaactools: A program for data analysis with PIAAC data,” The Stata Journal, 19(1): 112-128. https://doi.org/10.1177/1536867X19830909"
  },
  {
    "objectID": "blog/posts/Multilevel.html",
    "href": "blog/posts/Multilevel.html",
    "title": "マルチレベルモデルは点推定値に影響を及ぼすか？",
    "section": "",
    "text": "library(tidyverse)\nlibrary(lmerTest)\nlibrary(broom)\nlibrary(broom.mixed)"
  },
  {
    "objectID": "blog/posts/Multilevel.html#マルチレベルモデルにおけるよくある誤解",
    "href": "blog/posts/Multilevel.html#マルチレベルモデルにおけるよくある誤解",
    "title": "マルチレベルモデルは点推定値に影響を及ぼすか？",
    "section": "マルチレベルモデルにおけるよくある誤解",
    "text": "マルチレベルモデルにおけるよくある誤解\n「マルチレベルモデルでやんなきゃ係数にバイアスが…」←ホント？"
  },
  {
    "objectID": "blog/posts/Multilevel.html#データ生成",
    "href": "blog/posts/Multilevel.html#データ生成",
    "title": "マルチレベルモデルは点推定値に影響を及ぼすか？",
    "section": "データ生成",
    "text": "データ生成\nマルチレベルのデータを考える サンプルサイズ1000、グループ数50のデータ\n\\[\\begin{align}\ny_{ig} \\sim 0.5x_{ig} + \\mathrm{Normal}(\\theta_g, 1) \\\\\n\\theta_g \\sim \\mathrm{Normal}(0, 3) \\\\\nx_i \\sim \\mathrm{Normal}(0, 1)\n\\end{align}\\]\n\ndgp &lt;- function(samplesize = 1000) {\n  tibble(\n    id = 1:samplesize,\n    group = rep(1:50, 20),\n    x = rnorm(samplesize, mean = 0, sd = 1),\n  ) |&gt; \n    group_by(group) |&gt; \n    mutate(group_mean = rnorm(1, mean = 0, sd = 3)) |&gt; \n    ungroup() |&gt; \n    mutate(y = 0.5*x + rnorm(samplesize, mean = group_mean, sd = 1))\n}\n\ndata &lt;- dgp()\n\n\nlm(y ~ x, data = data) |&gt; \n  summary()\n\n\nCall:\nlm(formula = y ~ x, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.3427 -2.6225  0.0757  2.6275  7.6910 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   0.1105     0.1040   1.063 0.288194    \nx             0.3755     0.1033   3.635 0.000292 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.29 on 998 degrees of freedom\nMultiple R-squared:  0.01307,   Adjusted R-squared:  0.01208 \nF-statistic: 13.21 on 1 and 998 DF,  p-value: 0.0002921\n\nlmer(y ~ x + (1|group), data = data) |&gt; \n  summary()\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: y ~ x + (1 | group)\n   Data: data\n\nREML criterion at convergence: 3124.4\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-3.0764 -0.6308 -0.0189  0.6780  3.5932 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n group    (Intercept) 9.991    3.161   \n Residual             1.020    1.010   \nNumber of obs: 1000, groups:  group, 50\n\nFixed effects:\n             Estimate Std. Error        df t value Pr(&gt;|t|)    \n(Intercept)   0.10994    0.44814  48.99953   0.245    0.807    \nx             0.46983    0.03281 949.67653  14.321   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n  (Intr)\nx 0.000"
  },
  {
    "objectID": "blog/posts/Multilevel.html#シミュレーション",
    "href": "blog/posts/Multilevel.html#シミュレーション",
    "title": "マルチレベルモデルは点推定値に影響を及ぼすか？",
    "section": "シミュレーション",
    "text": "シミュレーション\nデータを1000個作成\n\ndata_list &lt;- \n  map(1:1000, \\(x) dgp(1000)) |&gt; \n  enframe()\n\nOLSと変量効果モデルで推定\n\nresult &lt;- \n  data_list |&gt; \n  mutate(\n    lm = map(value, \\(data) lm(y ~ x, data = data)),\n    lmer = map(value, \\(data) lmer(y ~ x + (1|group), data = data))\n  )\n\nxの係数のみ取り出す\n\nres2 &lt;- \n  result |&gt; \n  mutate(\n    lm_res = map(lm, \\(model) {\n      tidy(model) |&gt; \n        select(term, estimate)\n    }),\n    lmer_res = map(lmer, \\(model) {\n      tidy(model) |&gt; \n        select(term, estimate)\n    })\n  ) |&gt; \n  select(name, lm_res, lmer_res) |&gt; \n  pivot_longer(!name, names_to = 'model', values_to = 'value') |&gt; \n  unnest(value) |&gt; \n  filter(term == 'x')\n\n結果を図示\n\nどちらの点推定値も真の値の0.5を中心に分布＝バイアスはない\nOLSによる点推定値はバリアンスが大きい\n変量効果（マルチレベル）モデルによる点推定値はバリアンスが小さい\n\n\nres2 |&gt; \n  ggplot(aes(estimate, fill = model))+\n  geom_vline(xintercept = 0.5, linetype = 'dashed', alpha = 0.5)+\n  geom_histogram(alpha = 0.3, color = 'black', binwidth = 0.02, position = 'identity')+\n  scale_x_continuous(breaks = seq(0, 1, 0.2))"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html",
    "href": "blog/posts/移動平均のかゆいところに.html",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "",
    "text": "『前処理大全』の4章で移動平均の計算が出てきたのでメモ。\n移動平均の基本的な算出方法は「dplyrを使いこなす！Window関数編」などが詳しい。"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#はじめに",
    "href": "blog/posts/移動平均のかゆいところに.html#はじめに",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "",
    "text": "『前処理大全』の4章で移動平均の計算が出てきたのでメモ。\n移動平均の基本的な算出方法は「dplyrを使いこなす！Window関数編」などが詳しい。"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#移動平均の基本",
    "href": "blog/posts/移動平均のかゆいところに.html#移動平均の基本",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "移動平均の基本",
    "text": "移動平均の基本\nxにこんな感じでデータ入っているとき，移動平均は以下のように計算される。\n（以下ではすべて，3つずつ計算，右詰め，の前提で書く）\n\n\n\nx\nrollsum\nrollmean\n\n\n\n\n1\nNA\nNA\n\n\n2\nNA\nNA\n\n\n3\n1+2+3\n(1+2+3)/3\n\n\n4\n2+3+4\n(2+3+4)/3\n\n\n5\n3+4+5\n(3+4+5)/3\n\n\n6\n4+5+6\n(4+5+6)/3\n\n\n\nRで実装するとこんな感じになる\n\nlibrary(tidyverse)\n\ntibble(x = 1:6) |&gt; \n  mutate(\n    rollsum = RcppRoll::roll_sum(x, n = 3L, align = 'right', fill = NA),\n    rollmean = RcppRoll::roll_mean(x, n = 3L, align = 'right', fill = NA)\n  )\n\n# A tibble: 6 × 3\n      x rollsum rollmean\n  &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1     1      NA       NA\n2     2      NA       NA\n3     3       6        2\n4     4       9        3\n5     5      12        4\n6     6      15        5"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#移動平均のかゆいところ",
    "href": "blog/posts/移動平均のかゆいところに.html#移動平均のかゆいところ",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "移動平均のかゆいところ",
    "text": "移動平均のかゆいところ\nここまでの移動平均は，値が3つ揃っているところだけ計算し，3つに満たない端っこのケースに関しては欠損で埋める，というルールで計算している。\nただし，場合によっては3件に満たない場合でも欠損値扱いにせずに平均値を計算したい，という場合もあるだろう。\n（イメージ）\n\n\n\nx\nrollsum\nrollmean\n\n\n\n\n1\n1\n1/1\n\n\n2\n1+2\n(1+2)/2\n\n\n3\n1+2+3\n(1+2+3)/3\n\n\n4\n2+3+4\n(2+3+4)/3\n\n\n5\n3+4+5\n(3+4+5)/3\n\n\n6\n4+5+6\n(4+5+6)/3\n\n\n\n『前処理大全』でもこのようなケースが扱われており，Rのサンプルコードではlagと条件式の組み合わせで突破していたが，あんまりきれいじゃない。"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#zoorollapplyを用いた実装",
    "href": "blog/posts/移動平均のかゆいところに.html#zoorollapplyを用いた実装",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "zoo::rollapplyを用いた実装",
    "text": "zoo::rollapplyを用いた実装\n以上の問題を解決するにはzoo::rollapply()が有効である。\nこの関数の引数で，partial = TRUEとすると，以上の問題に対処できる。\n詳しくはvignetteを参照。\n\ntibble(x = 1:6) |&gt; \n  mutate(\n    rollsum = zoo::rollapply(x, width = 3L, FUN = sum, align = 'right', partial = TRUE),\n    rollmean = zoo::rollapply(x, width = 3L, FUN = mean, align = 'right', partial = TRUE)\n  )\n\n# A tibble: 6 × 3\n      x rollsum rollmean\n  &lt;int&gt;   &lt;int&gt;    &lt;dbl&gt;\n1     1       1      1  \n2     2       3      1.5\n3     3       6      2  \n4     4       9      3  \n5     5      12      4  \n6     6      15      5  \n\n\nこの場合1行目の値は和でも平均でも，元のデータがダイレクトに反映されることになる。\n最低でも2つ以上の値の場合だけ計算したい！という時は，partial = 2Lのように，引数に整数を入れればよい。\n\ntibble(x = 1:6) |&gt; \n  mutate(\n    rollsum = zoo::rollapply(x, width = 3L, FUN = sum, align = 'right', fill = NA, partial = 2L),\n    rollmean = zoo::rollapply(x, width = 3L, FUN = mean, align = 'right', fill = NA, partial = 2L)\n  )\n\n# A tibble: 6 × 3\n      x rollsum rollmean\n  &lt;int&gt;   &lt;int&gt;    &lt;dbl&gt;\n1     1      NA     NA  \n2     2       3      1.5\n3     3       6      2  \n4     4       9      3  \n5     5      12      4  \n6     6      15      5  \n\n\nまた，なぜかzoo::rollsumやzoo::rollmeanでpartial = TRUEとしても上手くいかない。なぜ…？\n\nzoo::rollapply(1:6, width = 3L, FUN = mean, align = 'right', partial = TRUE)\n\n[1] 1.0 1.5 2.0 3.0 4.0 5.0\n\nzoo::rollmean(1:6, k = 3L, align = 'right', partial = TRUE)\n\n[1] 2 3 4 5"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#rcpprollにもpartialがあるが",
    "href": "blog/posts/移動平均のかゆいところに.html#rcpprollにもpartialがあるが",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "RcppRollにもpartialがあるが…",
    "text": "RcppRollにもpartialがあるが…\n移動平均といえばRcppRollを使う人が多いはず。速度もzooより断然速いので基本的にはこちらを使うべきと筆者も思っている。\n実はRcppRollの関数にもpartial引数が入っている。\nこれを見た時に「これで行けるやん」と思ったのだが…\n\npartial Partial application? Currently unimplemented. https://cran.r-project.org/web/packages/RcppRoll/RcppRoll.pdf\n\n実装されてませんでした…"
  },
  {
    "objectID": "blog/posts/移動平均のかゆいところに.html#まとめ",
    "href": "blog/posts/移動平均のかゆいところに.html#まとめ",
    "title": "移動平均のかゆいところに，partial = TRUE",
    "section": "まとめ",
    "text": "まとめ\nというわけで，移動平均の計算は通常時はRcppRollを使いつつ，ああいった特殊な場合にはzooを使えばよいということがわかった。RcppRollは早くpartialを実装してほしいところ。"
  }
]